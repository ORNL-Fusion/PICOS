inputFiles/MPEX_Bfield_norm_scenario_14.txt:   9.9465065e-01
inputFiles/MPEX_Bfield_norm_scenario_14.txt:   9.9622204e-01
inputFiles/MPEX_Bfield_norm_scenario_14.txt:   9.9963237e-01
inputFiles/MPEX_Bfield_norm_scenario_14.txt:   9.9688312e-01
inputFiles/input_file.input:DTc                         1.0E-1
inputFiles/input_file.input:DrL                         -1
inputFiles/input_file.input:RF_handedness               -1
inputFiles/input_file.input:smoothingParameter          1.0E-4
t2021_08_09/MPEX_Bfield_norm_scenario_14.txt:   9.9465065e-01
t2021_08_09/MPEX_Bfield_norm_scenario_14.txt:   9.9622204e-01
t2021_08_09/MPEX_Bfield_norm_scenario_14.txt:   9.9963237e-01
t2021_08_09/MPEX_Bfield_norm_scenario_14.txt:   9.9688312e-01
Binary file t2021_08_09/HDF5/PARTICLES_FILE_21.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_23.h5 matches
Binary file t2021_08_09/HDF5/FIELDS_FILE_1.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_8.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_20.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_5.h5 matches
Binary file t2021_08_09/HDF5/main.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_2.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_6.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_25.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_26.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_17.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_11.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_28.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_4.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_13.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_0.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_14.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_15.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_9.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_18.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_22.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_3.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_12.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_10.h5 matches
Binary file t2021_08_09/HDF5/FIELDS_FILE_0.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_16.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_19.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_1.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_24.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_29.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_27.h5 matches
Binary file t2021_08_09/HDF5/PARTICLES_FILE_7.h5 matches
t2021_08_09/input_file.input:DTc                         1.0E-1
t2021_08_09/input_file.input:DrL                         -1
t2021_08_09/input_file.input:RF_handedness               -1
t2021_08_09/input_file.input:smoothingParameter          1.0E-4
compile.sh:make all -j4
compile.sh:    install_name_tool -change libarmadillo.4.dylib /home/nfc/myRepos/PICOS++/arma_libs/lib/libarmadillo.4.dylib bin/PICOS++
run_pro.sh:DIMENSIONALITY="1-D"
run_pro.sh:rm -r ${LOC_OUTPUT_FOLDER}"/"${ID}
run_pro.sh:    mpirun --use-hwthread-cpus -np $((NUM_MPI_PROCESSES)) -x LD_LIBRARY_PATH -x OMP_NUM_THREADS=$((NUM_OMP_PER_MPI)) bin/PICOS++ ${DIMENSIONALITY} ${LOC_OUTPUT_FOLDER}
run_pro.sh:    mpirun --use-hwthread-cpus -np $((NUM_MPI_PROCESSES)) -x LD_LIBRARY_PATH -x OMP_NUM_THREADS=$((NUM_OMP_PER_MPI)) bin/PICOS++ ${DIMENSIONALITY} ${LOC_OUTPUT_FOLDER} ${ID}
run_pro.sh:git log --oneline -1 > commitHash.txt
Binary file obj/main.o matches
Binary file obj/PIC.o matches
Binary file obj/units.o matches
Binary file obj/initDistribution.o matches
Binary file obj/types.o matches
Binary file obj/particleBC.o matches
Binary file obj/outputHDF5.o matches
Binary file obj/initialize.o matches
Binary file obj/mpi_main.o matches
profile_run_pro.sh:DIMENSIONALITY="1-D"
profile_run_pro.sh:rm -r ${LOC_OUTPUT_FOLDER}"/"${ID}
profile_run_pro.sh:    map --profile mpirun --use-hwthread-cpus -np $((NUM_MPI_PROCESSES)) -x LD_LIBRARY_PATH -x OMP_NUM_THREADS=$((NUM_OMP_PER_MPI)) bin/PICOS++ ${DIMENSIONALITY} ${LOC_OUTPUT_FOLDER}
profile_run_pro.sh:    map --profile mpirun --use-hwthread-cpus -np $((NUM_MPI_PROCESSES)) -x LD_LIBRARY_PATH -x OMP_NUM_THREADS=$((NUM_OMP_PER_MPI)) bin/PICOS++ ${DIMENSIONALITY} ${LOC_OUTPUT_FOLDER} ${ID}
src/outputHDF5.cpp:	unsigned int iIndex = params->mpi.iIndex;
src/outputHDF5.cpp:	unsigned int fIndex = params->mpi.fIndex;
src/outputHDF5.cpp:	arma::vec recvbuf(params->mesh.NX_IN_SIM);
src/outputHDF5.cpp:	arma::vec sendbuf(params->mesh.NX_PER_MPI);
src/outputHDF5.cpp:	//Allgather for x-component
src/outputHDF5.cpp:	sendbuf = field->subvec(iIndex, fIndex);
src/outputHDF5.cpp:	MPI_Allgather(sendbuf.memptr(), params->mesh.NX_PER_MPI, MPI_DOUBLE, recvbuf.memptr(), params->mesh.NX_PER_MPI, MPI_DOUBLE, params->mpi.MPI_TOPO);
src/outputHDF5.cpp:	field->subvec(1, params->mesh.NX_IN_SIM) = recvbuf;
src/outputHDF5.cpp:	unsigned int irow = params->mpi.irow;
src/outputHDF5.cpp:	unsigned int frow = params->mpi.frow;
src/outputHDF5.cpp:	unsigned int icol = params->mpi.icol;
src/outputHDF5.cpp:	unsigned int fcol = params->mpi.fcol;
src/outputHDF5.cpp:	arma::vec recvbuf = zeros(params->mesh.NX_IN_SIM*params->mesh.NY_IN_SIM);
src/outputHDF5.cpp:	arma::vec sendbuf = zeros(params->mesh.NX_PER_MPI*params->mesh.NY_PER_MPI);
src/outputHDF5.cpp:	//Allgather for x-component
src/outputHDF5.cpp:	sendbuf = vectorise(field->submat(irow,icol,frow,fcol));
src/outputHDF5.cpp:	MPI_Allgather(sendbuf.memptr(), params->mesh.NUM_CELLS_PER_MPI, MPI_DOUBLE, recvbuf.memptr(), params->mesh.NUM_CELLS_PER_MPI, MPI_DOUBLE, params->mpi.MPI_TOPO);
src/outputHDF5.cpp:	for (int mpis=0; mpis<params->mpi.NUMBER_MPI_DOMAINS; mpis++)
src/outputHDF5.cpp:		unsigned int ie = params->mesh.NX_PER_MPI*params->mesh.NY_PER_MPI*mpis;
src/outputHDF5.cpp:		unsigned int fe = params->mesh.NX_PER_MPI*params->mesh.NY_PER_MPI*(mpis+1) - 1;
src/outputHDF5.cpp:		unsigned int ir = *(params->mpi.MPI_CART_COORDS.at(mpis))*params->mesh.NX_PER_MPI + 1;
src/outputHDF5.cpp:		unsigned int fr = ( *(params->mpi.MPI_CART_COORDS.at(mpis)) + 1)*params->mesh.NX_PER_MPI;
src/outputHDF5.cpp:		unsigned int ic = *(params->mpi.MPI_CART_COORDS.at(mpis)+1)*params->mesh.NY_PER_MPI + 1;
src/outputHDF5.cpp:		unsigned int fc = ( *(params->mpi.MPI_CART_COORDS.at(mpis)+1) + 1)*params->mesh.NY_PER_MPI;
src/outputHDF5.cpp:		field->submat(ir,ic,fr,fc) = reshape(recvbuf.subvec(ie,fe), params->mesh.NX_PER_MPI, params->mesh.NY_PER_MPI);
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(file->createDataSet( nameSpace, PredType::NATIVE_INT, *dataspace ));
src/outputHDF5.cpp:	dataset->write( data, PredType::NATIVE_INT);
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(file->createDataSet( nameSpace, HDF_TYPE, *dataspace ));
src/outputHDF5.cpp:	dataset->write( data, HDF_TYPE);
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(group->createDataSet( nameSpace, PredType::NATIVE_INT, *dataspace ));
src/outputHDF5.cpp:	dataset->write( data, PredType::NATIVE_INT);
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(group->createDataSet( nameSpace, HDF_TYPE, *dataspace ));
src/outputHDF5.cpp:	dataset->write( data, HDF_TYPE);
src/outputHDF5.cpp:	unsigned long long int size = (unsigned long long int)values->size();
src/outputHDF5.cpp:        std::copy(values->begin(), values->end(), data);
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(file->createDataSet( nameSpace, PredType::NATIVE_INT, *dataspace ));
src/outputHDF5.cpp:	dataset->write( data, PredType::NATIVE_INT);
src/outputHDF5.cpp:	unsigned long long int size = (unsigned long long int)values->size();
src/outputHDF5.cpp:    std::copy(values->begin(), values->end(), data);
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(file->createDataSet( nameSpace, HDF_TYPE, *dataspace ));
src/outputHDF5.cpp:	dataset->write( data, HDF_TYPE);
src/outputHDF5.cpp:	hsize_t dims[1] = {(hsize_t)values->n_elem};
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(file->createDataSet( nameSpace, PredType::NATIVE_INT, *dataspace ));
src/outputHDF5.cpp:	dataset->write( values->memptr(), PredType::NATIVE_INT);
src/outputHDF5.cpp:	hsize_t dims[1] = {(hsize_t)values->n_elem};
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(group->createDataSet( nameSpace, PredType::NATIVE_INT, *dataspace ));
src/outputHDF5.cpp:	dataset->write( values->memptr(), PredType::NATIVE_INT);
src/outputHDF5.cpp:	hsize_t dims[1] = {(hsize_t)values->n_elem};
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(file->createDataSet( nameSpace, HDF_TYPE, *dataspace ));
src/outputHDF5.cpp:	dataset->write( values->memptr(), HDF_TYPE);
src/outputHDF5.cpp:	hsize_t dims[1] = {(hsize_t)values->n_elem};
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(group->createDataSet( nameSpace, HDF_TYPE, *dataspace ));
src/outputHDF5.cpp:	dataset->write( values->memptr(), HDF_TYPE);
src/outputHDF5.cpp:	hsize_t dims[1] = {(hsize_t)values->n_elem};
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(group->createDataSet( nameSpace, HDF_TYPE, *dataspace ));
src/outputHDF5.cpp:	dataset->write( values->memptr(), HDF_TYPE);
src/outputHDF5.cpp:	hsize_t dims[2] = {(hsize_t)values->n_cols, (hsize_t)values->n_rows};
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(file->createDataSet( nameSpace, PredType::NATIVE_INT, *dataspace ));
src/outputHDF5.cpp:	dataset->write( values->memptr(), PredType::NATIVE_INT);
src/outputHDF5.cpp:	hsize_t dims[2] = {(hsize_t)values->n_cols, (hsize_t)values->n_rows};
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(group->createDataSet( nameSpace, PredType::NATIVE_INT, *dataspace ));
src/outputHDF5.cpp:	dataset->write( values->memptr(), PredType::NATIVE_INT);
src/outputHDF5.cpp:	hsize_t dims[2] = {(hsize_t)values->n_cols, (hsize_t)values->n_rows};
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(group->createDataSet( nameSpace, HDF_TYPE, *dataspace ));
src/outputHDF5.cpp:	dataset->write( values->memptr(), HDF_TYPE);
src/outputHDF5.cpp:	hsize_t dims[2] = {(hsize_t)values->n_cols, (hsize_t)values->n_rows};
src/outputHDF5.cpp:	DataSet * dataset = new DataSet(group->createDataSet( nameSpace, HDF_TYPE, *dataspace ));
src/outputHDF5.cpp:	dataset->write( values->memptr(), HDF_TYPE);
src/outputHDF5.cpp:    if (params->mpi.MPI_DOMAIN_NUMBER == 0)
src/outputHDF5.cpp:        path = params->PATH + "/HDF5/";
src/outputHDF5.cpp:        saveToHDF5(outputFile, name, &params->dimensionality);
src/outputHDF5.cpp:        cpp_type_value = params->smoothingParameter;
src/outputHDF5.cpp:        saveToHDF5(outputFile, name, &params->numberOfRKIterations);
src/outputHDF5.cpp:        saveToHDF5(outputFile, name, &params->filtersPerIterationFields);
src/outputHDF5.cpp:        saveToHDF5(outputFile, name, &params->mpi.NUMBER_MPI_DOMAINS);
src/outputHDF5.cpp:        saveToHDF5(outputFile, name, &params->mpi.MPIS_PARTICLES);
src/outputHDF5.cpp:        saveToHDF5(outputFile, name, &params->mpi.MPIS_FIELDS);
src/outputHDF5.cpp:        Group * group_scales = new Group( outputFile->createGroup( "/scales" ) );
src/outputHDF5.cpp:        cpp_type_value = FS->electronSkinDepth;
src/outputHDF5.cpp:        cpp_type_value = FS->electronGyroPeriod;
src/outputHDF5.cpp:        cpp_type_value = FS->electronGyroRadius;
src/outputHDF5.cpp:        vec_values = zeros(params->numberOfParticleSpecies);
src/outputHDF5.cpp:        for (int ss=0; ss<params->numberOfParticleSpecies; ss++)
src/outputHDF5.cpp:                vec_values(ss) = FS->ionGyroRadius[ss];
src/outputHDF5.cpp:        fvec_values = zeros<fvec>(params->numberOfParticleSpecies);
src/outputHDF5.cpp:        for (int ss=0; ss<params->numberOfParticleSpecies; ss++)
src/outputHDF5.cpp:                fvec_values(ss) = (float)FS->ionGyroRadius[ss];
src/outputHDF5.cpp:        vec_values = zeros(params->numberOfParticleSpecies);
src/outputHDF5.cpp:        for (int ss=0; ss<params->numberOfParticleSpecies; ss++)
src/outputHDF5.cpp:                vec_values(ss) = FS->ionGyroPeriod[ss];
src/outputHDF5.cpp:        fvec_values = zeros<fvec>(params->numberOfParticleSpecies);
src/outputHDF5.cpp:        for (int ss=0; ss<params->numberOfParticleSpecies; ss++)
src/outputHDF5.cpp:                fvec_values(ss) = (float)FS->ionGyroPeriod[ss];
src/outputHDF5.cpp:        vec_values = zeros(params->numberOfParticleSpecies);
src/outputHDF5.cpp:        for (int ss=0; ss<params->numberOfParticleSpecies; ss++)
src/outputHDF5.cpp:                vec_values(ss) = FS->ionSkinDepth[ss];
src/outputHDF5.cpp:        fvec_values = zeros<fvec>(params->numberOfParticleSpecies);
src/outputHDF5.cpp:        for (int ss=0; ss<params->numberOfParticleSpecies; ss++)
src/outputHDF5.cpp:                fvec_values(ss) = (float)FS->ionSkinDepth[ss];
src/outputHDF5.cpp:        Group * group_geo = new Group( outputFile->createGroup( "/geometry" ) );
src/outputHDF5.cpp:        int_value = params->mesh.SPLIT_DIRECTION;
src/outputHDF5.cpp:        cpp_type_value = params->mesh.DX;
src/outputHDF5.cpp:        cpp_type_value = params->mesh.DY;
src/outputHDF5.cpp:        cpp_type_value = params->mesh.DZ;
src/outputHDF5.cpp:        cpp_type_value = params->mesh.LX;
src/outputHDF5.cpp:        cpp_type_value = params->mesh.LY;
src/outputHDF5.cpp:        cpp_type_value = params->mesh.LZ;
src/outputHDF5.cpp:        int_value = params->mesh.NX_PER_MPI;
src/outputHDF5.cpp:        int_value = params->mesh.NY_PER_MPI;
src/outputHDF5.cpp:        int_value = params->mesh.NZ_PER_MPI;
src/outputHDF5.cpp:        int_value = params->mesh.NX_IN_SIM;
src/outputHDF5.cpp:        int_value = params->mesh.NY_IN_SIM;
src/outputHDF5.cpp:        int_value = params->mesh.NZ_IN_SIM;
src/outputHDF5.cpp:        int_value = params->mpi.MPI_CART_COORDS_1D[0];
src/outputHDF5.cpp:        if (params->dimensionality == 1)
src/outputHDF5.cpp:          int_value = params->mpi.MPI_CART_COORDS_1D[0];
src/outputHDF5.cpp:          int_value = params->mpi.MPI_CART_COORDS_2D[0];
src/outputHDF5.cpp:          int_value = params->mpi.MPI_CART_COORDS_2D[1];
src/outputHDF5.cpp:        //Saving the x-axis coordinates
src/outputHDF5.cpp:        vec_values = params->mesh.nodesX;
src/outputHDF5.cpp:        fvec_values = conv_to<fvec>::from(params->mesh.nodesX);
src/outputHDF5.cpp:        if (params->dimensionality == 2)
src/outputHDF5.cpp:          vec_values = params->mesh.nodesY;
src/outputHDF5.cpp:          fvec_values = conv_to<fvec>::from(params->mesh.nodesY);
src/outputHDF5.cpp:        cpp_type_value = params->f_IC.Te*F_KB/F_E;
src/outputHDF5.cpp:        Group * group_ions = new Group( outputFile->createGroup( "/ions" ) );
src/outputHDF5.cpp:        int_value = params->numberOfParticleSpecies;
src/outputHDF5.cpp:        cpp_type_value = (CPP_TYPE)params->f_IC.ne;
src/outputHDF5.cpp:        for(int ii=0;ii<params->numberOfParticleSpecies;ii++)
src/outputHDF5.cpp:          Group * group_ionSpecies = new Group( outputFile->createGroup( name ) );
src/outputHDF5.cpp:          cpp_type_value = (CPP_TYPE)IONS->at(ii).p_IC.densityFraction;
src/outputHDF5.cpp:          cpp_type_value = (CPP_TYPE)IONS->at(ii).NCP;
src/outputHDF5.cpp:          cpp_type_value = (CPP_TYPE)IONS->at(ii).NSP;
src/outputHDF5.cpp:          cpp_type_value = (CPP_TYPE)IONS->at(ii).nSupPartOutput;
src/outputHDF5.cpp:          cpp_type_value = (CPP_TYPE)IONS->at(ii).p_IC.Tpar*F_KB/F_E;
src/outputHDF5.cpp:          cpp_type_value = (CPP_TYPE)IONS->at(ii).p_IC.Tper*F_KB/F_E;
src/outputHDF5.cpp:          cpp_type_value = (CPP_TYPE)IONS->at(ii).M;
src/outputHDF5.cpp:          cpp_type_value = (CPP_TYPE)IONS->at(ii).Q;
src/outputHDF5.cpp:          cpp_type_value = (CPP_TYPE)IONS->at(ii).Z;
src/outputHDF5.cpp:        vector_values = { (CPP_TYPE)params->em_IC.BX , (CPP_TYPE)params->em_IC.BX , (CPP_TYPE)params->em_IC.BX };
src/outputHDF5.cpp:    } // MPI-0
src/outputHDF5.cpp:		path = params->PATH + "/HDF5/";
src/outputHDF5.cpp:		dn << params->mpi.COMM_RANK;
src/outputHDF5.cpp:		if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/outputHDF5.cpp:		else if (params->mpi.COMM_COLOR == FIELDS_MPI_COLOR)
src/outputHDF5.cpp:		Group * group_iteration = new Group( outputFile->createGroup( group_iteration_name ) );
src/outputHDF5.cpp:		if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/outputHDF5.cpp:		else if (params->mpi.COMM_COLOR == FIELDS_MPI_COLOR)
src/outputHDF5.cpp:	unsigned int iIndex(params->mesh.NX_PER_MPI*params->mpi.MPI_DOMAIN_NUMBER_CART+1);
src/outputHDF5.cpp:	unsigned int fIndex(params->mesh.NX_PER_MPI*(params->mpi.MPI_DOMAIN_NUMBER_CART+1));
src/outputHDF5.cpp:		Group * group_ions = new Group( group_iteration->createGroup( "ions" ) );
src/outputHDF5.cpp:		for(int ii=0; ii<IONS->size(); ii++)
src/outputHDF5.cpp:			Group * group_ionSpecies = new Group( group_ions->createGroup( name ) );
src/outputHDF5.cpp:			for(int ov=0; ov<params->outputs_variables.size(); ov++)
src/outputHDF5.cpp:				if(params->outputs_variables.at(ov) == "X_p")
src/outputHDF5.cpp:					//Saving the x-axis coordinates
src/outputHDF5.cpp:					vec_values = CS->length*IONS->at(ii).X_p.col(0);
src/outputHDF5.cpp:					fvec_values = conv_to<fvec>::from(CS->length*IONS->at(ii).X_p.col(0));
src/outputHDF5.cpp:				 else if(params->outputs_variables.at(ov) == "pCount")
src/outputHDF5.cpp:					ivec_values = IONS->at(ii).pCount;
src/outputHDF5.cpp:				else if(params->outputs_variables.at(ov) == "eCount")
src/outputHDF5.cpp:					vec_values = (CS->velocity*CS->velocity*CS->mass)*IONS->at(ii).eCount;
src/outputHDF5.cpp:					fvec_values = conv_to<fvec>::from((CS->velocity*CS->velocity*CS->mass)*IONS->at(ii).eCount);
src/outputHDF5.cpp:				else if(params->outputs_variables.at(ov) == "V_p")
src/outputHDF5.cpp:					mat_values = CS->velocity*IONS->at(ii).V_p;
src/outputHDF5.cpp:					fmat_values = conv_to<fmat>::from(CS->velocity*IONS->at(ii).V_p);
src/outputHDF5.cpp:				else if(params->outputs_variables.at(ov) == "EX_p")
src/outputHDF5.cpp:					vec_values = CS->eField*IONS->at(ii).EX_p;
src/outputHDF5.cpp:					fvec_values = conv_to<fvec>::from( CS->eField*IONS->at(ii).EX_p);
src/outputHDF5.cpp:				else if(params->outputs_variables.at(ov) == "BX_p")
src/outputHDF5.cpp:					vec_values = CS->bField*IONS->at(ii).BX_p;
src/outputHDF5.cpp:					fvec_values = conv_to<fvec>::from( CS->bField*IONS->at(ii).BX_p);
src/outputHDF5.cpp:				if(params->outputs_variables.at(ov) == "n_p")
src/outputHDF5.cpp:					//Saving the x-axis coordinates
src/outputHDF5.cpp:					vec_values = IONS->at(ii).n_p/CS->length;
src/outputHDF5.cpp:					fvec_values = conv_to<fvec>::from(IONS->at(ii).n_p)/CS->length;
src/outputHDF5.cpp:				 if(params->outputs_variables.at(ov) == "nv_p")
src/outputHDF5.cpp:					 vec_values = IONS->at(ii).nv_p*CS->velocity/CS->length;
src/outputHDF5.cpp:					 fvec_values = conv_to<fvec>::from(IONS->at(ii).nv_p)*CS->velocity/CS->length;
src/outputHDF5.cpp:				  if(params->outputs_variables.at(ov) == "Tpar_p")
src/outputHDF5.cpp:					  vec_values = IONS->at(ii).Tpar_p*CS->temperature*F_KB/F_E;
src/outputHDF5.cpp:					  fvec_values = conv_to<fvec>::from(IONS->at(ii).Tpar_p)*CS->temperature*F_KB/F_E;
src/outputHDF5.cpp:				   if(params->outputs_variables.at(ov) == "Tper_p")
src/outputHDF5.cpp:					   vec_values = IONS->at(ii).Tper_p*CS->temperature*F_KB/F_E;
src/outputHDF5.cpp:					   fvec_values = conv_to<fvec>::from(IONS->at(ii).Tper_p)*CS->temperature*F_KB/F_E;
src/outputHDF5.cpp:				else if(params->outputs_variables.at(ov) == "n_m")
src/outputHDF5.cpp:					if (params->mpi.IS_PARTICLES_ROOT)
src/outputHDF5.cpp:						vec_values = IONS->at(ii).n_m.subvec(1,params->mesh.NX_IN_SIM)/CS->length;
src/outputHDF5.cpp:						fvec_values = conv_to<fvec>::from(IONS->at(ii).n_m.subvec(1,params->mesh.NX_IN_SIM)/CS->length);
src/outputHDF5.cpp:				else if(params->outputs_variables.at(ov) == "Tpar_m")
src/outputHDF5.cpp:					if (params->mpi.IS_PARTICLES_ROOT)
src/outputHDF5.cpp:						vec_values = IONS->at(ii).Tpar_m.subvec(1,params->mesh.NX_IN_SIM)*CS->temperature*F_KB/F_E;
src/outputHDF5.cpp:						fvec_values = conv_to<fvec>::from(IONS->at(ii).Tpar_m.subvec(1,params->mesh.NX_IN_SIM)*CS->temperature*F_KB/F_E);
src/outputHDF5.cpp:				else if(params->outputs_variables.at(ov) == "Tper_m")
src/outputHDF5.cpp:					if (params->mpi.IS_PARTICLES_ROOT)
src/outputHDF5.cpp:						vec_values = IONS->at(ii).Tper_m.subvec(1,params->mesh.NX_IN_SIM)*CS->temperature*F_KB/F_E;
src/outputHDF5.cpp:						fvec_values = conv_to<fvec>::from(IONS->at(ii).Tper_m.subvec(1,params->mesh.NX_IN_SIM)*CS->temperature*F_KB/F_E);
src/outputHDF5.cpp:				else if(params->outputs_variables.at(ov) == "mn")
src/outputHDF5.cpp:					ivec_values = IONS->at(ii).mn;
src/outputHDF5.cpp:				else if(params->outputs_variables.at(ov) == "u_m")
src/outputHDF5.cpp:					if (params->mpi.IS_PARTICLES_ROOT)
src/outputHDF5.cpp:						Group * group_bulkVelocity = new Group( group_ionSpecies->createGroup( "u_m" ) );
src/outputHDF5.cpp:						//x-component species bulk velocity
src/outputHDF5.cpp:						vec_values = CS->velocity*IONS->at(ii).nv_m.subvec(1,params->mesh.NX_IN_SIM)/IONS->at(ii).n_m.subvec(1,params->mesh.NX_IN_SIM);
src/outputHDF5.cpp:						fvec_values = conv_to<fvec>::from(CS->velocity*IONS->at(ii).nv_m.subvec(1,params->mesh.NX_IN_SIM)/IONS->at(ii).n_m.subvec(1,params->mesh.NX_IN_SIM));
src/outputHDF5.cpp:						//x-component species bulk velocity
src/outputHDF5.cpp:						vec_values = CS->velocity*IONS->at(ii).nv.Y.subvec(1,params->mesh.NX_IN_SIM)/IONS->at(ii).n.subvec(1,params->mesh.NX_IN_SIM);
src/outputHDF5.cpp:						fvec_values = conv_to<fvec>::from(CS->velocity*IONS->at(ii).nv.Y.subvec(1,params->mesh.NX_IN_SIM)/IONS->at(ii).n.subvec(1,params->mesh.NX_IN_SIM));
src/outputHDF5.cpp:						//x-component species bulk velocity
src/outputHDF5.cpp:						vec_values = CS->velocity*IONS->at(ii).nv.Z.subvec(1,params->mesh.NX_IN_SIM)/IONS->at(ii).n.subvec(1,params->mesh.NX_IN_SIM);
src/outputHDF5.cpp:						fvec_values = conv_to<fvec>::from(CS->velocity*IONS->at(ii).nv.Z.subvec(1,params->mesh.NX_IN_SIM)/IONS->at(ii).n.subvec(1,params->mesh.NX_IN_SIM));
src/outputHDF5.cpp:	unsigned int iIndex(params->mesh.NX_PER_MPI*params->mpi.MPI_DOMAIN_NUMBER_CART+1);
src/outputHDF5.cpp:	unsigned int fIndex(params->mesh.NX_PER_MPI*(params->mpi.MPI_DOMAIN_NUMBER_CART+1));
src/outputHDF5.cpp:		Group * group_fields = new Group( group_iteration->createGroup( "fields" ) );//Electromagnetic fields
src/outputHDF5.cpp:		for(int ov=0; ov<params->outputs_variables.size(); ov++)
src/outputHDF5.cpp:			if(params->outputs_variables.at(ov) == "EX_m")
src/outputHDF5.cpp:				Group * group_field = new Group( group_fields->createGroup( "EX_m" ) );//Electric fields
src/outputHDF5.cpp:				//x-component of electric field
src/outputHDF5.cpp:				vec_values = CS->eField*fields->EX_m.subvec(iIndex,fIndex);
src/outputHDF5.cpp:				fvec_values = conv_to<fvec>::from( CS->eField*fields->EX_m.subvec(iIndex,fIndex) );
src/outputHDF5.cpp:				//y-component of electric field
src/outputHDF5.cpp:				vec_values = CS->eField*fields->E.Y.subvec(iIndex,fIndex);
src/outputHDF5.cpp:				fvec_values = conv_to<fvec>::from( CS->eField*fields->E.Y.subvec(iIndex,fIndex) );
src/outputHDF5.cpp:				//z-component of electric field
src/outputHDF5.cpp:				vec_values = CS->eField*fields->E.Z.subvec(iIndex,fIndex);
src/outputHDF5.cpp:				fvec_values = conv_to<fvec>::from( CS->eField*fields->E.Z.subvec(iIndex,fIndex) );
src/outputHDF5.cpp:			if(params->outputs_variables.at(ov) == "BX_m")
src/outputHDF5.cpp:				Group * group_field = new Group( group_fields->createGroup( "BX_m" ) );//Electric fields
src/outputHDF5.cpp:				//x-component of magnetic field
src/outputHDF5.cpp:				vec_values = CS->bField*fields->BX_m.subvec(iIndex,fIndex);
src/outputHDF5.cpp:				fvec_values = conv_to<fvec>::from( CS->bField*fields->BX_m.subvec(iIndex,fIndex) );
src/outputHDF5.cpp:				//y-component of magnetic field
src/outputHDF5.cpp:				vec_values = CS->bField*fields->B.Y.subvec(iIndex,fIndex);
src/outputHDF5.cpp:				fvec_values = conv_to<fvec>::from( CS->bField*fields->B.Y.subvec(iIndex,fIndex) );
src/outputHDF5.cpp:				//z-component of magnetic field
src/outputHDF5.cpp:				vec_values = CS->bField*fields->B.Z.subvec(iIndex,fIndex);
src/outputHDF5.cpp:				fvec_values = conv_to<fvec>::from( CS->bField*fields->B.Z.subvec(iIndex,fIndex) );
src/outputHDF5.cpp:			if(params->outputs_variables.at(ov) == "dBX_m")
src/outputHDF5.cpp:				Group * group_field = new Group( group_fields->createGroup( "dBX_m" ) );//Electric fields
src/outputHDF5.cpp:				vec_values = fields->dBX_m.subvec(iIndex,fIndex)*CS->bField/CS->length;
src/outputHDF5.cpp:				fvec_values = conv_to<fvec>::from( fields->dBX_m.subvec(iIndex,fIndex)*CS->bField/CS->length );
src/outputHDF5.cpp:			if(params->outputs_variables.at(ov) == "ddBX_m")
src/outputHDF5.cpp:				Group * group_field = new Group( group_fields->createGroup( "ddBX_m" ) );//Electric fields
src/outputHDF5.cpp:				vec_values = fields->ddBX_m.subvec(iIndex,fIndex)*CS->bField/pow(CS->length,2);
src/outputHDF5.cpp:				fvec_values = conv_to<fvec>::from( fields->ddBX_m.subvec(iIndex,fIndex)*CS->bField/pow(CS->length,2) );
src/PIC.cpp:	arma::vec recvbuf = zeros(v->n_elem);
src/PIC.cpp:	MPI_Allreduce(v->memptr(), recvbuf.memptr(), v->n_elem, MPI_DOUBLE, MPI_SUM, params->mpi.MPI_TOPO);
src/PIC.cpp:	if (params->mpi.IS_PARTICLES_ROOT)
src/PIC.cpp:		MPI_Send(v->memptr(), v->n_elem, MPI_DOUBLE, params->mpi.FIELDS_ROOT_WORLD_RANK, PARTICLES_TAG, MPI_COMM_WORLD);
src/PIC.cpp:	if (params->mpi.IS_FIELDS_ROOT)
src/PIC.cpp:		MPI_Recv(v->memptr(), v->n_elem, MPI_DOUBLE, params->mpi.PARTICLES_ROOT_WORLD_RANK, PARTICLES_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
src/PIC.cpp:	if (params->mpi.COMM_COLOR == FIELDS_MPI_COLOR)
src/PIC.cpp:        MPI_Bcast(v->memptr(), v->n_elem, MPI_DOUBLE, 0, params->mpi.COMM);
src/PIC.cpp:    arma::vec recvbuf = zeros(v->n_elem);
src/PIC.cpp:    if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/PIC.cpp:        MPI_Reduce(v->memptr(), recvbuf.memptr(), v->n_elem, MPI_DOUBLE, MPI_SUM, 0, params->mpi.COMM);
src/PIC.cpp:        if (params->mpi.IS_PARTICLES_ROOT)
src/PIC.cpp:	unsigned int iIndex = params->mpi.iIndex;
src/PIC.cpp:	unsigned int fIndex = params->mpi.fIndex;
src/PIC.cpp:	arma::vec recvbuf(params->mesh.NX_IN_SIM);
src/PIC.cpp:	arma::vec sendbuf(params->mesh.NX_PER_MPI);
src/PIC.cpp:	sendbuf = field->subvec(iIndex, fIndex);
src/PIC.cpp:	MPI_Allgather(sendbuf.memptr(), params->mesh.NX_PER_MPI, MPI_DOUBLE, recvbuf.memptr(), params->mesh.NX_PER_MPI, MPI_DOUBLE, params->mpi.MPI_TOPO);
src/PIC.cpp:	field->subvec(1, params->mesh.NX_IN_SIM) = recvbuf;
src/PIC.cpp:	arma::vec recvbuf(params->mesh.NX_IN_SIM);
src/PIC.cpp:	arma::vec sendbuf(params->mesh.NX_IN_SIM);
src/PIC.cpp:	sendbuf = field->subvec(1, params->mesh.NX_IN_SIM);
src/PIC.cpp:	if (params->mpi.IS_FIELDS_ROOT)
src/PIC.cpp:		MPI_Send(sendbuf.memptr(), params->mesh.NX_IN_SIM, MPI_DOUBLE, params->mpi.PARTICLES_ROOT_WORLD_RANK, 0, MPI_COMM_WORLD);
src/PIC.cpp:	if (params->mpi.IS_PARTICLES_ROOT)
src/PIC.cpp:		MPI_Recv(recvbuf.memptr(), params->mesh.NX_IN_SIM, MPI_DOUBLE, params->mpi.FIELDS_ROOT_WORLD_RANK, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
src/PIC.cpp:		field->subvec(1, params->mesh.NX_IN_SIM) = recvbuf;
src/PIC.cpp:	if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/PIC.cpp:		sendbuf = field->subvec(1, params->mesh.NX_IN_SIM);
src/PIC.cpp:		MPI_Bcast(sendbuf.memptr(), params->mesh.NX_IN_SIM, MPI_DOUBLE, 0, params->mpi.COMM);
src/PIC.cpp:		field->subvec(1, params->mesh.NX_IN_SIM) = sendbuf;
src/PIC.cpp:	int NX = C->n_elem;
src/PIC.cpp:	(*C)(NX-1) = (*C)(NX-2);
src/PIC.cpp:	//int N = v->n_elem;
src/PIC.cpp:	//v->subvec(N-2,N-1) = v->subvec(2,3);
src/PIC.cpp:	//v->subvec(0,1) = v->subvec(N-4,N-3);
src/PIC.cpp:    // Triangular Shape Cloud (TSC) scheme. See Sec. 5-3-2 of R. Hockney and J. Eastwood, Computer Simulation Using Particles.
src/PIC.cpp:    // --------*------------*--------X---*--------
src/PIC.cpp:    //wxc = 0.75 - (x/H)^2
src/PIC.cpp:    //wxr = 0.5*(1.5 - abs(x)/H)^2
src/PIC.cpp:    //wxl = 0.5*(1.5 - abs(x)/H)^2
src/PIC.cpp:    int NX =  params->mesh.NX_IN_SIM + 4; //Mesh size along the X axis (considering the gosht cell)
src/PIC.cpp:    int NSP(IONS->NSP);
src/PIC.cpp:    // Fill in vector F with mesh-defined data:
src/PIC.cpp:    F.subvec(1,NX-2) = *F_m;
src/PIC.cpp:        int ix = IONS->mn(ii) + 2;
src/PIC.cpp:        (*F_p)(ii) += IONS->wxl(ii)*F(ix-1);
src/PIC.cpp:        (*F_p)(ii) += IONS->wxc(ii)*F(ix);
src/PIC.cpp:        (*F_p)(ii) += IONS->wxr(ii)*F(ix+1);
src/PIC.cpp:    double dx   = params->mesh.DX;
src/PIC.cpp:    int m       = round( 0.5 + (xp - xMin)/dx ) - 1;
src/PIC.cpp:    if ( m >= params->mesh.NX_IN_SIM)
src/PIC.cpp:        m = params->mesh.NX_IN_SIM - 1;
src/PIC.cpp:    double X    = params->mesh.nodesX(m) - xp;
src/PIC.cpp:    W(0) = 0.5*pow( 1.5 + ((X - dx)/dx) ,2); // Left:
src/PIC.cpp:    W(1) = 0.75 - pow(X/dx,2);               // Center:
src/PIC.cpp:    W(2) = 0.5*pow(1.5 - ((X + dx)/dx) ,2 ); // Right:
src/PIC.cpp:    f(0) = fields->EX_m(ix - 1);
src/PIC.cpp:    f(1) = fields->EX_m(ix - 0);
src/PIC.cpp:    f(2) = fields->EX_m(ix + 1);
src/PIC.cpp:    f(0) = fields->BX_m(ix - 1);
src/PIC.cpp:    f(1) = fields->BX_m(ix - 0);
src/PIC.cpp:    f(2) = fields->BX_m(ix + 1);
src/PIC.cpp:    if (params->mpi.IS_PARTICLES_ROOT)
src/PIC.cpp:            cout << "xp ="<< xp*CS->length << endl;
src/PIC.cpp:            cout << "BX = "<< (*EM)(1)*CS->bField << endl;
src/PIC.cpp:            cout << "f(0) = "<< f(0)*CS->bField << endl;
src/PIC.cpp:            cout << "f(1) = "<< f(1)*CS->bField << endl;
src/PIC.cpp:            cout << "f(2) = "<< f(2)*CS->bField << endl;
src/PIC.cpp:    f(0) = fields->dBX_m(ix - 1);
src/PIC.cpp:    f(1) = fields->dBX_m(ix - 0);
src/PIC.cpp:    f(2) = fields->dBX_m(ix + 1);
src/PIC.cpp:    double qa = IONS->Q;
src/PIC.cpp:    double Ma = IONS->M;
src/PIC.cpp:    (*F)(1) = -0.5*vper*vper*dB/B + qa*E/Ma;
src/PIC.cpp:    // Get latest mesh-defined values from FIELDS MPIs:
src/PIC.cpp:    MPI_Recvvec(params,&fields->EX_m);
src/PIC.cpp:    MPI_Recvvec(params,&fields->BX_m);
src/PIC.cpp:    MPI_Recvvec(params,&fields->dBX_m);
src/PIC.cpp:	fillGhosts(&fields->EX_m);
src/PIC.cpp:    fillGhosts(&fields->BX_m);
src/PIC.cpp:    fillGhosts(&fields->dBX_m);
src/PIC.cpp:	for(int ss=0; ss<IONS->size(); ss++)
src/PIC.cpp:		if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/PIC.cpp:            arma::vec EX_p  = zeros(IONS->at(ss).NSP, 1);
src/PIC.cpp:			arma::vec BX_p  = zeros(IONS->at(ss).NSP, 1);
src/PIC.cpp:            arma::vec dBX_p = zeros(IONS->at(ss).NSP, 1);
src/PIC.cpp:            // Interpolate mesh-defined fields into particles:
src/PIC.cpp:            interpolateScalarField(params, &IONS->at(ss), &fields->EX_m , &EX_p );
src/PIC.cpp:            interpolateScalarField(params, &IONS->at(ss), &fields->BX_m , &BX_p );
src/PIC.cpp:            interpolateScalarField(params, &IONS->at(ss), &fields->dBX_m, &dBX_p);
src/PIC.cpp:			IONS->at(ss).EX_p  = EX_p;
src/PIC.cpp:			IONS->at(ss).BX_p  = BX_p;
src/PIC.cpp:            IONS->at(ss).dBX_p = dBX_p;
src/PIC.cpp:			int NSP = IONS->at(ss).NSP;
src/PIC.cpp:            double DT = params->DT;
src/PIC.cpp:                ! F(2) = -0.5*vp*vp*dB/B + (q/Ma)*E
src/PIC.cpp:                double x    = IONS->at(ss).X_p(ii);
src/PIC.cpp:                double vpar = IONS->at(ss).V_p(ii,0);
src/PIC.cpp:                double vper = IONS->at(ss).V_p(ii,1);
src/PIC.cpp:                // Extract particle-defined fields:
src/PIC.cpp:                double E  = IONS->at(ss).EX_p(ii);
src/PIC.cpp:                double B  = IONS->at(ss).BX_p(ii);
src/PIC.cpp:                double dB = IONS->at(ss).dBX_p(ii);
src/PIC.cpp:                interpEM(params, CS, &IONS->at(ss), fields, &ZN, &EM);
src/PIC.cpp:                calculateF(params, CS, &IONS->at(ss), &ZN, &EM, &F);
src/PIC.cpp:                interpEM(params, CS, &IONS->at(ss), fields, &ZN, &EM);
src/PIC.cpp:                calculateF(params, CS, &IONS->at(ss), &ZN, &EM, &F);
src/PIC.cpp:                interpEM(params, CS, &IONS->at(ss), fields, &ZN, &EM);
src/PIC.cpp:                calculateF(params, CS, &IONS->at(ss), &ZN, &EM, &F);
src/PIC.cpp:                interpEM(params, CS, &IONS->at(ss), fields, &ZN, &EM);
src/PIC.cpp:                calculateF(params, CS, &IONS->at(ss), &ZN, &EM, &F);
src/PIC.cpp:                IONS->at(ss).X_p(ii)   = ZN(0);
src/PIC.cpp:                IONS->at(ss).V_p(ii,0) = ZN(1);
src/PIC.cpp:                IONS->at(ss).V_p(ii,1) = ZN(2);
src/units.cpp:    if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/units.cpp:	for (int ii=0; ii<params->numberOfParticleSpecies; ii++)
src/units.cpp:	    CS->mass += IONS->at(ii).M;
src/units.cpp:	    CS->charge += fabs(IONS->at(ii).Q);
src/units.cpp:	CS->mass   /= params->numberOfParticleSpecies;
src/units.cpp:	CS->charge /= params->numberOfParticleSpecies;
src/units.cpp:	CS->density = params->CV.ne;
src/units.cpp:	double characteristicPlasmaFrequency(0);//Background ion-plasma frequency.
src/units.cpp:	characteristicPlasmaFrequency = sqrt( CS->density*CS->charge*CS->charge/(CS->mass*F_EPSILON) );
src/units.cpp:	CS->time = 1/characteristicPlasmaFrequency;
src/units.cpp:	CS->velocity = F_C;
src/units.cpp:	CS->momentum = CS->mass*CS->velocity;
src/units.cpp:	CS->length = CS->velocity*CS->time;
src/units.cpp:	CS->volume = CS->length*CS->length*CS->length;
src/units.cpp:	CS->eField = ( CS->mass*CS->velocity )/( CS->charge*CS->time );
src/units.cpp:	CS->bField = CS->eField/CS->velocity; // CS->mass/( CS->charge*CS->time );
src/units.cpp:	CS->temperature = CS->mass*CS->velocity*CS->velocity/F_KB;
src/units.cpp:	CS->pressure = CS->bField*CS->velocity*CS->velocity*CS->charge*CS->density*CS->time;
src/units.cpp:	CS->resistivity = CS->bField/(CS->charge*CS->density);
src/units.cpp:	CS->magneticMoment = CS->mass*CS->velocity*CS->velocity/CS->bField;
src/units.cpp:	CS->vacuumPermittivity = (pow(CS->length*CS->charge,2)*CS->density)/(CS->mass*pow(CS->velocity,2));
src/units.cpp:	CS->vacuumPermeability = CS->mass/( CS->density*pow(CS->charge*CS->velocity*CS->time,2) );
src/units.cpp:    CS->energy = CS->mass*pow(CS->length/CS->time,2);
src/units.cpp:	if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/units.cpp:		cout << "+ Average mass: " << scientific << CS->mass << fixed << " kg" << endl;
src/units.cpp:		cout << "+ Average charge: " << scientific << CS->charge << fixed << " C" << endl;
src/units.cpp:		cout << "+ Density: " << scientific << CS->density << fixed << " m^(-3)" << endl;
src/units.cpp:		cout << "+ Time: " << scientific << CS->time << fixed << " s" << endl;
src/units.cpp:		cout << "+ Velocity: " << scientific << CS->velocity << fixed << " m/s" << endl;
src/units.cpp:		cout << "+ Length: " << scientific << CS->length << fixed << " m" << endl;
src/units.cpp:		cout << "+ Electric field intensity: " << scientific << CS->eField << fixed << " V/m" << endl;
src/units.cpp:		cout << "+ Magnetic field intensity: " << scientific << CS->bField << fixed << " T" << endl;
src/units.cpp:		cout << "+ Pressure: " << scientific << CS->pressure << fixed << " Pa" << endl;
src/units.cpp:		cout << "+ Temperature: " << scientific << CS->temperature << fixed << " K" << endl;
src/units.cpp:		cout << "+ Magnetic moment: " << scientific << CS->magneticMoment << fixed << " A*m^2" << endl;
src/units.cpp:		cout << "+ Resistivity: " << scientific << CS->magneticMoment << fixed << " Ohms*m" << endl;
src/units.cpp:		cout << "+ Vacuum permittivity: " << scientific << CS->vacuumPermittivity << fixed << "" << endl;
src/units.cpp:		cout << "+ Vacuum permeability: " << scientific << CS->vacuumPermeability << fixed << "" << endl;
src/units.cpp:    MPI_Bcast(&CS->time, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->velocity, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->momentum, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->length, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:	MPI_Bcast(&CS->volume, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->mass, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->charge, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->density, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->eField, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->bField, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->pressure, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->temperature, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->magneticMoment, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->resistivity, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->vacuumPermeability, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->vacuumPermittivity, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(&CS->energy, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/units.cpp:    params->ionLarmorRadius = FS->ionGyroRadius[0];
src/units.cpp:    params->ionSkinDepth = FS->ionSkinDepth[0];
src/units.cpp:    params->ionGyroPeriod = FS->ionGyroPeriod[0];
src/units.cpp:	FS->electronSkinDepth  = F_C/sqrt( params->CV.ne*F_E*F_E/(F_EPSILON*F_ME) );
src/units.cpp:	FS->electronGyroPeriod = 2.0*M_PI/(F_E*params->CV.B/F_ME);
src/units.cpp:	FS->electronGyroRadius = sqrt(2.0*F_KB*params->CV.Te/F_ME)/(F_E*params->CV.B/F_ME);
src/units.cpp:	cout << " + Electron gyro-period: " << scientific << FS->electronGyroPeriod << fixed << " s" << endl;
src/units.cpp:	cout << " + Electron skin depth: " << scientific << FS->electronSkinDepth << fixed << " m" << endl;
src/units.cpp:	cout << " + Electron gyro-radius: " << scientific << FS->electronGyroRadius << fixed << " m" << endl;
src/units.cpp:	for(int ss=0; ss<params->numberOfParticleSpecies; ss++){
src/units.cpp:		FS->ionGyroPeriod[ss] = 2.0*M_PI/IONS->at(ss).Wc;
src/units.cpp:		FS->ionSkinDepth[ss]  = F_C/IONS->at(ss).Wp;
src/units.cpp:		FS->ionGyroRadius[ss] = IONS->at(ss).LarmorRadius;
src/units.cpp:		cout << " + Ion gyro-period: " << scientific << FS->ionGyroPeriod[ss] << fixed << " s" << endl;
src/units.cpp:		cout << " + Ion skin depth: " << scientific << FS->ionSkinDepth[ss] << fixed << " m" << endl;
src/units.cpp:		cout << " + Ion gyro-radius: " << scientific << FS->ionGyroRadius[ss] << fixed << " m" << endl;
src/units.cpp:    MPI_Bcast(&FS->electronSkinDepth, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    // Electron gyro-period
src/units.cpp:    MPI_Bcast(&FS->electronGyroPeriod, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    // Electron gyro-radius
src/units.cpp:    MPI_Bcast(&FS->electronGyroRadius, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    MPI_Bcast(FS->ionSkinDepth, params->numberOfParticleSpecies, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    // Ion gyro-period
src/units.cpp:    MPI_Bcast(FS->ionGyroPeriod, params->numberOfParticleSpecies, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:    // Ion gyro-radius
src/units.cpp:    MPI_Bcast(FS->ionGyroRadius, params->numberOfParticleSpecies, MPI_DOUBLE, 0, MPI_COMM_WORLD);
src/units.cpp:	if (params->mpi.MPI_DOMAIN_NUMBER == 0)
src/units.cpp:        cout << "Electron skin depth to grid size ratio: " << scientific << FS->electronSkinDepth/params->mesh.DX << fixed << endl;
src/units.cpp:	if (params->mesh.DX <= FS->electronSkinDepth)
src/units.cpp:        cout << "ERROR: Grid size violates assumptions of hybrid model for the plasma -- lenght scales smaller than the electron skind depth can not be resolved." << endl;
src/units.cpp:        MPI_Abort(MPI_COMM_WORLD,-103);
src/units.cpp:	if (params->mpi.IS_PARTICLES_ROOT)
src/units.cpp:	DT = params->DTc*params->ionGyroPeriod;
src/units.cpp:	if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/units.cpp:            for (int ss=0; ss<params->numberOfParticleSpecies; ss++)
src/units.cpp:                    vec V = sqrt( pow(IONS->at(ss).V_p.col(0), 2.0) + pow(IONS->at(ss).V_p.col(1), 2.0) );
src/units.cpp:            DT_CFL_I = params->mesh.DX/ionsMaxVel;
src/units.cpp:            DT_CFL_I_MPI = (double*)malloc( params->mpi.MPIS_PARTICLES*sizeof(double) );
src/units.cpp:            MPI_Allgather(&DT_CFL_I, 1, MPI_DOUBLE, DT_CFL_I_MPI, 1, MPI_DOUBLE, params->mpi.COMM);
src/units.cpp:            if (params->mpi.IS_PARTICLES_ROOT)
src/units.cpp:                for (int ii=0; ii<params->mpi.MPIS_PARTICLES; ii++)
src/units.cpp:				params->DT = DT;
src/units.cpp:                params->timeIterations = (int)ceil( params->simulationTime*params->ionGyroPeriod/params->DT );
src/units.cpp:                params->outputCadenceIterations = (int)ceil( params->outputCadence*params->ionGyroPeriod/params->DT );
src/units.cpp:	MPI_Bcast(&params->DT, 1, MPI_DOUBLE, params->mpi.PARTICLES_ROOT_WORLD_RANK, MPI_COMM_WORLD);
src/units.cpp:	MPI_Bcast(&params->timeIterations, 1, MPI_INT, params->mpi.PARTICLES_ROOT_WORLD_RANK, MPI_COMM_WORLD);
src/units.cpp:	MPI_Bcast(&params->outputCadenceIterations, 1, MPI_INT, params->mpi.PARTICLES_ROOT_WORLD_RANK, MPI_COMM_WORLD);
src/units.cpp:	if (params->mpi.IS_PARTICLES_ROOT)
src/units.cpp:            cout << "+ Time step used in simulation: " << scientific << params->DT << fixed << endl;
src/units.cpp:            cout << "+ Time steps in simulation: " << params->timeIterations << endl;
src/units.cpp:            cout << "+ Simulation time: " << scientific << params->DT*params->timeIterations << fixed << " s" << endl;
src/units.cpp:            cout << "+ Simulation time: " << params->DT*params->timeIterations/params->ionGyroPeriod << " gyroperiods" << endl;
src/units.cpp:            cout << "+ Cadence for saving outputs: " << params->outputCadenceIterations << endl;
src/units.cpp:            cout << "+ Number of outputs: " << floor(params->timeIterations/params->outputCadenceIterations) + 1 << endl;
src/units.cpp:            cout << "+ Cadence for checking stability: " << params->rateOfChecking << endl;
src/units.cpp:	F_E_DS /= CS->charge; 					// Dimensionless electron charge
src/units.cpp:	F_ME_DS /= CS->mass; 					// Dimensionless electron charge
src/units.cpp:	F_MU_DS /= CS->vacuumPermeability; 		// Dimensionless vacuum permeability
src/units.cpp:	F_EPSILON_DS /= CS->vacuumPermittivity;	// Dimensionless vacuum permittivity
src/units.cpp:	F_C_DS /= CS->velocity; 				// Dimensionless speed of light
src/units.cpp:	// ---------------
src/units.cpp:	params->DT /= CS->time;
src/units.cpp:    to be normalized too. Ideally we would like ne to be in m^-3
src/units.cpp:	// ----------------------
src/units.cpp:	params->CV.ne /= CS->density;
src/units.cpp:	params->CV.Te /= CS->temperature;
src/units.cpp:	params->CV.B /= CS->bField;
src/units.cpp:	params->CV.Tpar /= CS->temperature;
src/units.cpp:	params->CV.Tper /= CS->temperature;
src/units.cpp:	// -------------------------
src/units.cpp:	params->f_IC.ne /= CS->density;
src/units.cpp:	params->f_IC.Te /= CS->temperature;
src/units.cpp:	// -----------------------------------------
src/units.cpp:	params->em_IC.BX 	 	 /= CS->bField;
src/units.cpp:	params->em_IC.BY     	 /= CS->bField;
src/units.cpp:	params->em_IC.BZ         /= CS->bField;
src/units.cpp:	params->em_IC.Bx_profile /= CS->bField;
src/units.cpp:	params->em_IC.EX 	 	 /= CS->eField;
src/units.cpp:	params->em_IC.EY     	 /= CS->eField;
src/units.cpp:	params->em_IC.EZ         /= CS->eField;
src/units.cpp:	params->em_IC.Ex_profile /= CS->eField;
src/units.cpp:	// ---------
src/units.cpp:	params->geometry.r1 /= CS->length;
src/units.cpp:	params->geometry.r2 /= CS->length;
src/units.cpp:    // params->geometry.A_0 /= pow(CS->length,2);
src/units.cpp:	// -------------------
src/units.cpp:	params->ionLarmorRadius /= CS->length;
src/units.cpp:	params->ionSkinDepth /= CS->length;
src/units.cpp:	params->ionGyroPeriod /= CS->time;
src/units.cpp:	// ----------------
src/units.cpp:	params->mesh.nodesX = params->mesh.nodesX/CS->length;
src/units.cpp:	params->mesh.nodesY = params->mesh.nodesY/CS->length;
src/units.cpp:	params->mesh.nodesZ = params->mesh.nodesZ/CS->length;
src/units.cpp:	params->mesh.DX /= CS->length;
src/units.cpp:	params->mesh.DY /= CS->length;
src/units.cpp:	params->mesh.DZ /= CS->length;
src/units.cpp:	params->mesh.LX /= CS->length;
src/units.cpp:	params->mesh.LY /= CS->length;
src/units.cpp:	params->mesh.LZ /= CS->length;
src/units.cpp:	for(int ii=0;ii<IONS->size();ii++)
src/units.cpp:		// ----------------------------
src/units.cpp:		IONS->at(ii).p_BC.mean_x  /= CS->length;
src/units.cpp:		IONS->at(ii).p_BC.sigma_x /= CS->length;
src/units.cpp:		IONS->at(ii).p_BC.T /= CS->temperature;
src/units.cpp:		IONS->at(ii).p_BC.E /= CS->temperature;
src/units.cpp:		// -------------------
src/units.cpp:		IONS->at(ii).Q /= CS->charge;
src/units.cpp:		IONS->at(ii).M /= CS->mass;
src/units.cpp:		// ----------------------------
src/units.cpp:		IONS->at(ii).p_IC.Tpar /= CS->temperature;
src/units.cpp:		IONS->at(ii).p_IC.Tper /= CS->temperature;
src/units.cpp:		IONS->at(ii).p_IC.Tper_profile /= CS->temperature;
src/units.cpp:		IONS->at(ii).p_IC.Tpar_profile /= CS->temperature;
src/units.cpp:		IONS->at(ii).p_IC.densityFraction_profile /= CS->density;
src/units.cpp:		IONS->at(ii).LarmorRadius /= CS->length;
src/units.cpp:		IONS->at(ii).VTpar /= CS->velocity;
src/units.cpp:		IONS->at(ii).VTper /= CS->velocity;
src/units.cpp:		IONS->at(ii).Wc *= CS->time;
src/units.cpp:		IONS->at(ii).Wp *= CS->time;
src/units.cpp:		if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/units.cpp:                    IONS->at(ii).X_p = IONS->at(ii).X_p/CS->length;
src/units.cpp:                    IONS->at(ii).V_p = IONS->at(ii).V_p/CS->velocity;
src/units.cpp:	fields->EX_m   /=  CS->eField;
src/units.cpp:	fields->BX_m   /=  CS->bField;
src/units.cpp:    fields->dBX_m  /= (CS->bField/pow(CS->length,1));
src/units.cpp:    fields->ddBX_m /= (CS->bField/pow(CS->length,2));
src/types.h:#define float_zero 1E-7
src/types.h:#define double_zero 1E-15
src/types.h:#define PRO_ZERO 1.0E-15	// Definition of zero in PROMETHEUS
src/types.h:#define F_E 1.602176E-19	// Electron charge in C (absolute value)
src/types.h:#define F_ME 9.109382E-31	// Electron mass in kg
src/types.h:#define F_MP 1.672621E-27	// Proton mass in kg
src/types.h:#define F_U 1.660538E-27	// Atomic mass unit in kg
src/types.h:#define F_KB 1.380650E-23	// Boltzmann constant in Joules/Kelvin
src/types.h:#define F_EPSILON 8.854E-12 // Vacuum permittivity in C^2/(N*m^2)
src/types.h:#define F_MU (4*M_PI)*1E-7 	// Vacuum permeability in N/A^2
src/types.h:	vfield_vec_TYP operator - (vfield_vec_TYP R);
src/types.h:	vfield_vec_TYP operator -= (vfield_vec_TYP R);
src/types.h:	vfield_mat_TYP operator - (vfield_mat_TYP R);
src/types.h:	vfield_mat_TYP operator -= (vfield_mat_TYP R);
src/types.h:	// variables for controlling super-particles' outputs
src/types.h:	// Guiding-center variables
src/types.h:	//arma::vec Ppar; 			// Parallel momentum used in guiding-center orbits
src/types.h:    // Mesh-defined ion moments:
src/types.h:	arma::vec n_m__; 				// Ion density at time level "l - 1"
src/types.h:	arma::vec n_m___; 			// Ion density at time level "l - 2"
src/types.h:	arma::vec nv_m_; 			// Ion bulk velocity at time level "l - 1/2"
src/types.h:	arma::vec nv_m__; 			// Ion bulk velocity at time level "l - 3/2"
src/types.h:	// Particle-defined ion moments:
src/types.h:	int NX_PER_MPI; // Number of mesh nodes along x-axis in subdomain (no ghost nodes considered)
src/types.h:	int NY_PER_MPI; // Number of mesh nodes along y-axis in subdomain (no ghost nodes considered)
src/types.h:	int NZ_PER_MPI; // Number of mesh nodes along z-axis in subdomain (no ghost nodes considered)
src/types.h:	int NX_IN_SIM; // Number of mesh nodes along x-axis in entire simulation domain (no ghost nodes considered)
src/types.h:	int NY_IN_SIM; // Number of mesh nodes along x-axis in entire simulation domain (no ghost nodes considered)
src/types.h:	int NZ_IN_SIM; // Number of mesh nodes along x-axis in entire simulation domain (no ghost nodes considered)
src/types.h:	double LX;		// Size of simulation domain along x-axis
src/types.h:	double LY;		// Size of simulation domain along y-axis
src/types.h:	double LZ;		// Size of simulation domain along z-axis
src/types.h:	// ---------------------------------------------------------------------------
src/types.h:	// ---------------------------------------------------------------------------
src/types.h:	double simulationTime; // In units of the shorter ion gyro-period in the simulation
src/types.h:	int numberOfParticleSpecies; // This species are evolved self-consistently with the fields
src/types.h:	int numberOfTracerSpecies; // This species are not self-consistently evolved with the fields
src/types.h:		ionSkinDepth = new double[params->numberOfParticleSpecies];
src/types.h:		ionGyroPeriod = new double[params->numberOfParticleSpecies];
src/types.h:		ionGyroRadius = new double[params->numberOfParticleSpecies];
src/mpi_main.cpp:    // params->mpi.MPI_DOMAIN_NUMBER is defined in constructor is INITIALIZE
src/mpi_main.cpp:	// Define the color of each MPI sub-communicator:
src/mpi_main.cpp:	if (params->mpi.MPI_DOMAIN_NUMBER < params->mpi.MPIS_FIELDS)
src/mpi_main.cpp:        params->mpi.COMM_COLOR = FIELDS_MPI_COLOR; // Color of fields' communicator
src/mpi_main.cpp:        params->mpi.COMM_COLOR = PARTICLES_MPI_COLOR; // Color of particles' communicator
src/mpi_main.cpp:	// key = params->mpi.MPI_DOMAIN_NUMBER
src/mpi_main.cpp:    MPI_Comm_split(MPI_COMM_WORLD, params->mpi.COMM_COLOR, params->mpi.MPI_DOMAIN_NUMBER, &params->mpi.COMM);
src/mpi_main.cpp:    MPI_Comm_rank(params->mpi.COMM, &params->mpi.COMM_RANK);
src/mpi_main.cpp:	MPI_Comm_size(params->mpi.COMM, &params->mpi.COMM_SIZE);
src/mpi_main.cpp:    if ((params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR) && (params->mpi.COMM_RANK == 0))
src/mpi_main.cpp:		params->mpi.IS_PARTICLES_ROOT = true;
src/mpi_main.cpp:		params->mpi.PARTICLES_ROOT_WORLD_RANK = params->mpi.MPI_DOMAIN_NUMBER;
src/mpi_main.cpp:		params->mpi.IS_PARTICLES_ROOT = false;
src/mpi_main.cpp:		params->mpi.PARTICLES_ROOT_WORLD_RANK = -1;
src/mpi_main.cpp:	if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/mpi_main.cpp:	MPI_Bcast(&params->mpi.PARTICLES_ROOT_WORLD_RANK, 1, MPI_INT, 0, params->mpi.COMM);
src/mpi_main.cpp:	MPI_Bcast(&params->mpi.PARTICLES_ROOT_WORLD_RANK, 1, MPI_INT, (params->mpi.NUMBER_MPI_DOMAINS - 1), MPI_COMM_WORLD);
src/mpi_main.cpp:	if ((params->mpi.COMM_COLOR == FIELDS_MPI_COLOR) && (params->mpi.COMM_RANK == 0))
src/mpi_main.cpp:		params->mpi.IS_FIELDS_ROOT = true;
src/mpi_main.cpp:		params->mpi.FIELDS_ROOT_WORLD_RANK = params->mpi.MPI_DOMAIN_NUMBER;
src/mpi_main.cpp:		params->mpi.IS_FIELDS_ROOT = false;
src/mpi_main.cpp:		params->mpi.FIELDS_ROOT_WORLD_RANK = -1;
src/mpi_main.cpp:	if (params->mpi.COMM_COLOR == FIELDS_MPI_COLOR)
src/mpi_main.cpp:	       MPI_Bcast(&params->mpi.FIELDS_ROOT_WORLD_RANK, 1, MPI_INT, 0, params->mpi.COMM);
src/mpi_main.cpp:	MPI_Bcast(&params->mpi.FIELDS_ROOT_WORLD_RANK, 1, MPI_INT, 0, MPI_COMM_WORLD);
src/mpi_main.cpp:	// cout << "WORLD RANK: " << params->mpi.MPI_DOMAIN_NUMBER << " | IS PM: " << params->mpi.IS_PARTICLES_ROOT << " | IS FM: " << params->mpi.IS_FIELDS_ROOT << " | PMWR: " <<  params->mpi.PARTICLES_ROOT_WORLD_RANK << " | FMWR:" << params->mpi.FIELDS_ROOT_WORLD_RANK << endl;
src/mpi_main.cpp:    if (params->mpi.COMM_COLOR == FIELDS_MPI_COLOR)
src/mpi_main.cpp:        int dims_1D[1] = {params->mpi.MPIS_FIELDS};
src/mpi_main.cpp:        params->mpi.MPI_DOMAINS_ALONG_X_AXIS = params->mpi.MPIS_FIELDS;
src/mpi_main.cpp:        params->mpi.MPI_DOMAINS_ALONG_Y_AXIS = 1;
src/mpi_main.cpp:        params->mpi.MPI_DOMAINS_ALONG_Z_AXIS = 1;
src/mpi_main.cpp:        MPI_Cart_create(params->mpi.COMM, ndims, dims_1D, periods_1D, reorder, &params->mpi.MPI_TOPO);
src/mpi_main.cpp:        MPI_Topo_test(params->mpi.MPI_TOPO, &topo_status);
src/mpi_main.cpp:            MPI_Comm_rank(params->mpi.MPI_TOPO, &params->mpi.MPI_DOMAIN_NUMBER_CART);
src/mpi_main.cpp:            MPI_Cart_coords(params->mpi.MPI_TOPO, params->mpi.MPI_DOMAIN_NUMBER_CART, ndims, params->mpi.MPI_CART_COORDS_1D);
src/mpi_main.cpp:			for (int mpis=0; mpis<params->mpi.MPIS_FIELDS; mpis++)
src/mpi_main.cpp:				int * COORDS = new int[2*params->mpi.MPIS_FIELDS];
src/mpi_main.cpp:				MPI_Allgather(&params->mpi.MPI_CART_COORDS_2D, 2, MPI_INT, COORDS, 2, MPI_INT, params->mpi.MPI_TOPO);
src/mpi_main.cpp:				params->mpi.MPI_CART_COORDS.push_back(new int[2]);
src/mpi_main.cpp:				*(params->mpi.MPI_CART_COORDS.at(mpis)) = *(COORDS + 2*mpis);
src/mpi_main.cpp:				*(params->mpi.MPI_CART_COORDS.at(mpis) + 1) = *(COORDS + 2*mpis + 1);
src/mpi_main.cpp:			src = params->mpi.MPI_DOMAIN_NUMBER_CART;
src/mpi_main.cpp:			MPI_Cart_shift(params->mpi.MPI_TOPO, 0, 1, &src, &params->mpi.RIGHT_MPI_DOMAIN_NUMBER_CART);
src/mpi_main.cpp:			src = params->mpi.MPI_DOMAIN_NUMBER_CART;
src/mpi_main.cpp:			MPI_Cart_shift(params->mpi.MPI_TOPO, 0, -1, &src, &params->mpi.LEFT_MPI_DOMAIN_NUMBER_CART);
src/mpi_main.cpp:            params->mpi.iIndex = params->mesh.NX_PER_MPI*params->mpi.MPI_DOMAIN_NUMBER_CART+1;
src/mpi_main.cpp:            params->mpi.fIndex = params->mesh.NX_PER_MPI*(params->mpi.MPI_DOMAIN_NUMBER_CART+1);
src/mpi_main.cpp:			if (params->mpi.MPI_DOMAIN_NUMBER_CART == 0)
src/mpi_main.cpp:                cout << "+ Number of MPI processes along the x-axis: " << dims_1D[0] << endl;
src/mpi_main.cpp:                cout << "+ Number of mesh nodes along x-axis: " << params->mesh.NX_IN_SIM << endl;
src/mpi_main.cpp:				cout << "+ Number of MPI processes for FIELDS: " << params->mpi.MPIS_FIELDS << endl;
src/mpi_main.cpp:				cout << "+ Number of MPI processes for PARTICLES: " << params->mpi.MPIS_PARTICLES << endl;
src/mpi_main.cpp:			MPI_Abort(MPI_COMM_WORLD,-102);
src/mpi_main.cpp:	if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/mpi_main.cpp:	MPI_Comm_free(&params->mpi.COMM);
src/mpi_main.cpp:		cout << "MPI process: " << params->mpi.MPI_DOMAIN_NUMBER << " FINALIZED" << endl;
src/mpi_main.cpp:		cout << "MPI process: " << params->mpi.MPI_DOMAIN_NUMBER << " NOT FINALIZED - ERROR" << endl;
src/mpi_main.cpp:	if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:        string token = str.substr(prev, pos-prev);
src/initialize.cpp:    reader.open(inputFile->data(),ifstream::in);
src/initialize.cpp:    	MPI_Abort(MPI_COMM_WORLD, -101);
src/initialize.cpp:    MPI_Comm_size(MPI_COMM_WORLD, &params->mpi.NUMBER_MPI_DOMAINS);
src/initialize.cpp:    MPI_Comm_rank(MPI_COMM_WORLD, &params->mpi.MPI_DOMAIN_NUMBER);
src/initialize.cpp:    params->errorCodes[-100] = "Odd number of MPI processes";
src/initialize.cpp:    params->errorCodes[-101] = "Input file could not be opened";
src/initialize.cpp:    params->errorCodes[-102] = "MPI's Cartesian topology could not be created";
src/initialize.cpp:    params->errorCodes[-103] = "Grid size violates assumptions of hybrid model for the plasma -- DX smaller than the electron skind depth can not be resolved";
src/initialize.cpp:    params->errorCodes[-104] = "Loading external electromagnetic fields not implemented yet";
src/initialize.cpp:    params->errorCodes[-105] = "Restart not implemented yet";
src/initialize.cpp:    params->errorCodes[-106] = "Inconsistency in iniital ion's velocity distribution function";
src/initialize.cpp:    params->errorCodes[-107] = "Inconsistency in iniital ion's spatial distribution function";
src/initialize.cpp:    params->errorCodes[-108] = "Non-finite value in meshNode";
src/initialize.cpp:    params->errorCodes[-109] = "Number of nodes in either direction of simulation domain need to be a multiple of 2";
src/initialize.cpp:    params->errorCodes[-110] = "Non finite values in Ex";
src/initialize.cpp:    params->errorCodes[-111] = "Non finite values in Ey";
src/initialize.cpp:    params->errorCodes[-112] = "Non finite values in Ez";
src/initialize.cpp:    params->errorCodes[-113] = "Non finite values in Bx";
src/initialize.cpp:    params->errorCodes[-114] = "Non finite values in By";
src/initialize.cpp:    params->errorCodes[-115] = "Non finite values in Bz";
src/initialize.cpp:    if (params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:        cout << "* PICOS++, a 1D-2V GC hybrid PIC code for open plasma systems           *" << endl;
src/initialize.cpp:    params->PATH = argv[2];
src/initialize.cpp:	params->argc = argc;
src/initialize.cpp:	params->argv = argv;
src/initialize.cpp:	if( fmod( (double)params->mpi.NUMBER_MPI_DOMAINS, 2.0 ) > 0.0 )
src/initialize.cpp:		if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:		MPI_Abort(MPI_COMM_WORLD,-100);
src/initialize.cpp:    if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:        cout << "STARTING " << params->argv[1] << " SIMULATION ON: " << std::ctime(&current_time) << endl;
src/initialize.cpp:	if(params->argc > 3)
src/initialize.cpp:		string argv(params->argv[3]);
src/initialize.cpp:		params->PATH += "/" + argv;
src/initialize.cpp:		params->PATH += "/";
src/initialize.cpp:	if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:		string mkdir_outputs_dir = "mkdir " + params->PATH;
src/initialize.cpp:    // -------------------------------------------------------------------------
src/initialize.cpp:    params->mpi.MPIS_FIELDS  = stoi( parametersStringMap["mpisForFields"] );
src/initialize.cpp:        params->quietStart = true;
src/initialize.cpp:        params->quietStart = false;
src/initialize.cpp:    params->numberOfRKIterations    = stoi( parametersStringMap["numberOfRKIterations"] );
src/initialize.cpp:    params->numberOfParticleSpecies = stoi( parametersStringMap["numberOfParticleSpecies"] );
src/initialize.cpp:    params->numberOfTracerSpecies   = stoi( parametersStringMap["numberOfTracerSpecies"] );
src/initialize.cpp:    // -------------------------------------------------------------------------
src/initialize.cpp:    params->CV.ne   = stod( parametersStringMap["CV_ne"] );
src/initialize.cpp:    params->CV.Te   = stod( parametersStringMap["CV_Te"] )*F_E/F_KB;
src/initialize.cpp:    params->CV.B    = stod( parametersStringMap["CV_B"] );
src/initialize.cpp:    params->CV.Tpar = stod( parametersStringMap["CV_Tpar"] )*F_E/F_KB;
src/initialize.cpp:    params->CV.Tper = stod( parametersStringMap["CV_Tper"] )*F_E/F_KB;
src/initialize.cpp:    // -------------------------------------------------------------------------
src/initialize.cpp:    params->DTc            = stod( parametersStringMap["DTc"] );
src/initialize.cpp:    params->simulationTime = std::stod( parametersStringMap["simulationTime"] );
src/initialize.cpp:    // -------------------------------------------------------------------------
src/initialize.cpp:    params->SW.EfieldSolve   = stoi( parametersStringMap["SW_EfieldSolve"] );
src/initialize.cpp:    params->SW.HallTermSolve = stoi( parametersStringMap["SW_HallTermSolve"] );
src/initialize.cpp:    params->SW.BfieldSolve   = stoi( parametersStringMap["SW_BfieldSolve"] );
src/initialize.cpp:    params->SW.Collisions    = stoi( parametersStringMap["SW_Collisions"] );
src/initialize.cpp:    params->SW.RFheating     = stoi( parametersStringMap["SW_RFheating"] );
src/initialize.cpp:    params->SW.advancePos    = stoi( parametersStringMap["SW_advancePos"] );
src/initialize.cpp:    params->SW.linearSolve   = stoi( parametersStringMap["SW_linearSolve"] );
src/initialize.cpp:    // -------------------------------------------------------------------------
src/initialize.cpp:    params->em_IC.uniformBfield = stoi( parametersStringMap["IC_uniformBfield"] );
src/initialize.cpp:    params->em_IC.BX            = stod( parametersStringMap["IC_BX"] );
src/initialize.cpp:    params->em_IC.BY            = stod( parametersStringMap["IC_BY"] );
src/initialize.cpp:    params->em_IC.BZ            = stod( parametersStringMap["IC_BZ"] );
src/initialize.cpp:    params->em_IC.BX_NX         = stoi( parametersStringMap["IC_BX_NX"] );
src/initialize.cpp:    params->em_IC.BX_fileName   = parametersStringMap["IC_BX_fileName"];
src/initialize.cpp:    // -------------------------------------------------------------------------
src/initialize.cpp:    params->DrL          = stod( parametersStringMap["DrL"] );
src/initialize.cpp:    params->dp           = stod( parametersStringMap["dp"] );
src/initialize.cpp:    params->geometry.r1  = stod( parametersStringMap["r1"] );
src/initialize.cpp:    params->geometry.r2  = stod( parametersStringMap["r2"] );
src/initialize.cpp:    // -------------------------------------------------------------------------
src/initialize.cpp:    params->f_IC.ne      = stod( parametersStringMap["IC_ne"] );
src/initialize.cpp:    params->f_IC.Te      = stod( parametersStringMap["IC_Te"] )*F_E/F_KB; // Te in eV in input file
src/initialize.cpp:    // -------------------------------------------------------------------------
src/initialize.cpp:    params->outputCadence           = stod( parametersStringMap["outputCadence"] );
src/initialize.cpp:    string nonparsed_variables_list = parametersStringMap["outputs_variables"].substr(1, parametersStringMap["outputs_variables"].length() - 2);
src/initialize.cpp:    params->outputs_variables       = split(nonparsed_variables_list,",");
src/initialize.cpp:    // -------------------------------------------------------------------------
src/initialize.cpp:    params->smoothingParameter        = stod( parametersStringMap["smoothingParameter"] );
src/initialize.cpp:    params->filtersPerIterationFields = stoi( parametersStringMap["filtersPerIterationFields"] );
src/initialize.cpp:    params->filtersPerIterationIons   = stoi( parametersStringMap["filtersPerIterationIons"] );
src/initialize.cpp:    params->mpi.MPIS_PARTICLES = params->mpi.NUMBER_MPI_DOMAINS - params->mpi.MPIS_FIELDS;
src/initialize.cpp:    params->geometry.A_0 = M_PI*(pow(params->geometry.r2,2) -pow(params->geometry.r1,2));
src/initialize.cpp:        MPI_Barrier(params->mpi.MPI_TOPO);
src/initialize.cpp:        MPI_Abort(params->mpi.MPI_TOPO,-109);
src/initialize.cpp:    params->mesh.NX_IN_SIM = NX;
src/initialize.cpp:    params->mesh.NX_PER_MPI = (int)( (double)NX/(double)params->mpi.MPIS_FIELDS );
src/initialize.cpp:    params->mesh.SPLIT_DIRECTION = 0;
src/initialize.cpp:    params->mesh.NY_IN_SIM = 1;
src/initialize.cpp:    params->mesh.NY_PER_MPI = 1;
src/initialize.cpp:    params->mesh.NZ_IN_SIM = 1;
src/initialize.cpp:    params->mesh.NZ_PER_MPI = 1;
src/initialize.cpp:    params->mesh.NUM_CELLS_PER_MPI = params->mesh.NX_PER_MPI;
src/initialize.cpp:    params->mesh.NUM_CELLS_IN_SIM = params->mesh.NX_IN_SIM;
src/initialize.cpp:    if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:    	cout << "+ Number of ion species: " << params->numberOfParticleSpecies << endl;
src/initialize.cpp:    	cout << "+ Number of tracer species: " << params->numberOfTracerSpecies << endl;
src/initialize.cpp:    if(params->argc > 3)
src/initialize.cpp:    	string argv(params->argv[3]);
src/initialize.cpp:    int totalNumSpecies(params->numberOfParticleSpecies + params->numberOfTracerSpecies);
src/initialize.cpp:            // Species type, -1: Guiding center, 0: Tracer, 1: Full orbit
src/initialize.cpp:            ions.Wc    = ions.Q*params->CV.B/ions.M;
src/initialize.cpp:            ions.Wp    = sqrt( ions.p_IC.densityFraction*params->CV.ne*ions.Q*ions.Q/(F_EPSILON*ions.M) );//Check the definition of the plasma freq for each species!
src/initialize.cpp:            ions.VTper = sqrt(2.0*F_KB*params->CV.Tper/ions.M);
src/initialize.cpp:            ions.VTpar = sqrt(2.0*F_KB*params->CV.Tpar/ions.M);
src/initialize.cpp:            ions.NSP = ceil( ions.NPC*(double)params->mesh.NUM_CELLS_IN_SIM/(double)params->mpi.MPIS_PARTICLES );
src/initialize.cpp:            IONS->push_back(ions);
src/initialize.cpp:            if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:                    cout << endl << "Species No "  << ii + 1 << " are full-orbit particles with the following parameters:" << endl;
src/initialize.cpp:                cout << "+ User-defined number of particles per MPI: " << ions.NSP << endl;
src/initialize.cpp:                cout << "+ Parallel temperature: " << params->CV.Tpar*F_KB/F_E << " eV" << endl;
src/initialize.cpp:                cout << "+ Perpendicular temperature: " << params->CV.Tper*F_KB/F_E << " eV" << endl;
src/initialize.cpp:            if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:                cerr << "PRO++ ERROR: Enter a valid type of species -- options are 0 = tracers, 1 = full orbit, -1 = guiding center" << endl;
src/initialize.cpp:            MPI_Abort(MPI_COMM_WORLD,-106);
src/initialize.cpp:    if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:    if (params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:    if( (params->DrL > 0.0) && (params->dp < 0.0) )
src/initialize.cpp:    	params->mesh.DX = params->DrL*params->ionLarmorRadius;
src/initialize.cpp:    	params->mesh.DY = params->mesh.DX;
src/initialize.cpp:    	params->mesh.DZ = params->mesh.DX;
src/initialize.cpp:    	if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:    else if( (params->DrL < 0.0) && (params->dp > 0.0) )
src/initialize.cpp:        params->mesh.DX = params->dp*params->ionSkinDepth;
src/initialize.cpp:        params->mesh.DY = params->mesh.DX;
src/initialize.cpp:        params->mesh.DZ = params->mesh.DX;
src/initialize.cpp:        if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:    params->mesh.nodes.X.set_size(params->mesh.NX_IN_SIM);
src/initialize.cpp:    params->mesh.nodes.Y.set_size(params->mesh.NY_IN_SIM);
src/initialize.cpp:    params->mesh.nodes.Z.set_size(params->mesh.NZ_IN_SIM);
src/initialize.cpp:    params->mesh.nodesX.set_size(params->mesh.NX_IN_SIM);
src/initialize.cpp:    params->mesh.nodesY.set_size(params->mesh.NY_IN_SIM);
src/initialize.cpp:    params->mesh.nodesZ.set_size(params->mesh.NZ_IN_SIM);
src/initialize.cpp:    for(int ii=0; ii<params->mesh.NX_IN_SIM; ii++)
src/initialize.cpp:        //params->mesh.nodes.X(ii) = (double)ii*params->mesh.DX;
src/initialize.cpp:        params->mesh.nodesX(ii) = (double)ii*params->mesh.DX;
src/initialize.cpp:    for(int ii=0; ii<params->mesh.NY_IN_SIM; ii++)
src/initialize.cpp:        //params->mesh.nodes.Y(ii) = (double)ii*params->mesh.DY;
src/initialize.cpp:        params->mesh.nodesY(ii) = (double)ii*params->mesh.DY;
src/initialize.cpp:    for(int ii=0; ii<params->mesh.NZ_IN_SIM; ii++)
src/initialize.cpp:        //params->mesh.nodes.Z(ii) = (double)ii*params->mesh.DZ;
src/initialize.cpp:        params->mesh.nodesZ(ii) = (double)ii*params->mesh.DZ;
src/initialize.cpp:    params->mesh.LX = params->mesh.DX*params->mesh.NX_IN_SIM;
src/initialize.cpp:    params->mesh.LY = params->mesh.DY*params->mesh.NY_IN_SIM;
src/initialize.cpp:    params->mesh.LZ = params->mesh.DZ*params->mesh.NZ_IN_SIM;
src/initialize.cpp:    if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:        cout << "+ Number of mesh nodes along x-axis: " << params->mesh.NX_IN_SIM << endl;
src/initialize.cpp:        cout << "+ Number of mesh nodes along y-axis: " << params->mesh.NY_IN_SIM << endl;
src/initialize.cpp:        cout << "+ Number of mesh nodes along z-axis: " << params->mesh.NZ_IN_SIM << endl;
src/initialize.cpp:    	cout << "+ Size of simulation domain along the x-axis: " << params->mesh.LX << " m" << endl;
src/initialize.cpp:    	cout << "+ Size of simulation domain along the y-axis: " << params->mesh.LY << " m" << endl;
src/initialize.cpp:    	cout << "+ Size of simulation domain along the z-axis: " << params->mesh.LZ << " m" << endl;
src/initialize.cpp:    int NX(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    int nn = params->PATH.length();
src/initialize.cpp:    std::string inputFilePath = params->PATH.substr(0,nn-13);
src/initialize.cpp:    for(int ii=0;ii<IONS->size();ii++)
src/initialize.cpp:        std::string fileName  = params->PATH.substr(0,nn-13);
src/initialize.cpp:        std::string fileName2 = fileName + "/inputFiles/" + IONS->at(ii).p_IC.Tper_fileName;
src/initialize.cpp:        std::string fileName3 = fileName + "/inputFiles/" + IONS->at(ii).p_IC.Tpar_fileName;
src/initialize.cpp:        std::string fileName4 = fileName + "/inputFiles/" + IONS->at(ii).p_IC.densityFraction_fileName;
src/initialize.cpp:        IONS->at(ii).p_IC.Tper_profile.load(fileName2);
src/initialize.cpp:        IONS->at(ii).p_IC.Tpar_profile.load(fileName3);
src/initialize.cpp:        IONS->at(ii).p_IC.densityFraction_profile.load(fileName4);
src/initialize.cpp:        IONS->at(ii).p_IC.Tper_profile *= IONS->at(ii).p_IC.Tper;
src/initialize.cpp:        IONS->at(ii).p_IC.Tpar_profile *= IONS->at(ii).p_IC.Tpar;
src/initialize.cpp:        IONS->at(ii).p_IC.densityFraction_profile *= params->f_IC.ne;
src/initialize.cpp:        if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:	if (params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:    if (params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:        cout << "+ Magnetic field along x-axis: " << scientific << params->em_IC.BX << fixed << " T" << endl;
src/initialize.cpp:        cout << "+ Magnetic field along y-axis: " << scientific << params->em_IC.BY << fixed << " T" << endl;
src/initialize.cpp:        cout << "+ Magnetic field along z-axis: " << scientific << params->em_IC.BZ << fixed << " T" << endl;
src/initialize.cpp:	if (params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:    int NX(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    fields->zeros(NX);
src/initialize.cpp:    if (params->em_IC.uniformBfield)
src/initialize.cpp:        fields->B.Z.fill(params->em_IC.BZ);
src/initialize.cpp:        fields->B.Y.fill(params->em_IC.BY);
src/initialize.cpp:        fields->B.X.fill(params->em_IC.BX);
src/initialize.cpp:        fields->BX_m.fill(params->em_IC.BX);
src/initialize.cpp:        int nn = params->PATH.length();
src/initialize.cpp:        std::string fileName = params->PATH.substr(0,nn-13);
src/initialize.cpp:        fileName = fileName + "/inputFiles/" + params->em_IC.BX_fileName;
src/initialize.cpp:        params->em_IC.Bx_profile.load(fileName);
src/initialize.cpp:        params->em_IC.Bx_profile *= params->em_IC.BX;
src/initialize.cpp:        arma::vec xq = linspace(0,params->mesh.LX,NX);
src/initialize.cpp:        int BX_NX  = params->em_IC.BX_NX;
src/initialize.cpp:        double dX = params->mesh.LX/((double)BX_NX);
src/initialize.cpp:        //double dBX_NX = params->mesh.LX/BX_NX;
src/initialize.cpp:        arma::vec xt = linspace(0,params->mesh.LX,BX_NX); // x-vector from the table
src/initialize.cpp:        yt = params->em_IC.Bx_profile;
src/initialize.cpp:        fields->BX_m = yq;
src/initialize.cpp:        dBX.subvec(0,BX_NX-2) = diff(params->em_IC.Bx_profile,1)/dX;
src/initialize.cpp:        dBX(BX_NX-1) = dBX(BX_NX-2);
src/initialize.cpp:        fields->dBX_m = yq;
src/initialize.cpp:        ddBX.subvec(0,BX_NX-3) = diff(params->em_IC.Bx_profile,2)/(dX*dX);
src/initialize.cpp:        ddBX(BX_NX-2) = ddBX(BX_NX-3);
src/initialize.cpp:        ddBX(BX_NX-1) = ddBX(BX_NX-2);
src/initialize.cpp:        fields->ddBX_m = yq;
src/initialize.cpp:    int totalNumSpecies(params->numberOfParticleSpecies + params->numberOfTracerSpecies);
src/initialize.cpp:    if (params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:        if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/initialize.cpp:            switch (IONS->at(ii).p_IC.IC_type)
src/initialize.cpp:                    if (params->quietStart)
src/initialize.cpp:                        initDist.uniform_maxwellianDistribution(params, &IONS->at(ii));
src/initialize.cpp:                        initDist.nonuniform_maxwellianDistribution(params, &IONS->at(ii));
src/initialize.cpp:            initializeParticlesArrays(params, fields, &IONS->at(ii));
src/initialize.cpp:            initializeBulkVariablesArrays(params, &IONS->at(ii));
src/initialize.cpp:        else if (params->mpi.COMM_COLOR == FIELDS_MPI_COLOR)
src/initialize.cpp:            initializeBulkVariablesArrays(params, &IONS->at(ii));
src/initialize.cpp:        MPI_Bcast(&IONS->at(ii).NSP, 1, MPI_DOUBLE, params->mpi.PARTICLES_ROOT_WORLD_RANK, MPI_COMM_WORLD);
src/initialize.cpp:        MPI_Bcast(&IONS->at(ii).nSupPartOutput, 1, MPI_DOUBLE, params->mpi.PARTICLES_ROOT_WORLD_RANK, MPI_COMM_WORLD);
src/initialize.cpp:        double ds    = params->mesh.LX/params->em_IC.BX_NX;
src/initialize.cpp:        arma::vec ni = ones<vec>(params->em_IC.BX_NX);
src/initialize.cpp:        arma::vec A  = ones<vec>(params->em_IC.BX_NX);
src/initialize.cpp:        if (params->quietStart)
src/initialize.cpp:            ni *= params->f_IC.ne*IONS->at(ii).p_IC.densityFraction;
src/initialize.cpp:            A  = A*params->geometry.A_0;
src/initialize.cpp:            ni = IONS->at(ii).p_IC.densityFraction_profile;
src/initialize.cpp:            A  = params->geometry.A_0*(params->em_IC.BX/params->em_IC.Bx_profile);
src/initialize.cpp:        // NCP conversion factor from super-particle to real particle:
src/initialize.cpp:        double NSP  = IONS->at(ii).NSP*params->mpi.MPIS_PARTICLES;
src/initialize.cpp:        IONS->at(ii).NCP = NR/NSP;
src/initialize.cpp:        if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:            cout << "NCP = " << IONS->at(ii).NCP << endl;
src/initialize.cpp:        if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:            if (params->quietStart)
src/initialize.cpp:            cout << "+ Super-particles used in simulation: " << IONS->at(ii).NSP*params->mpi.MPIS_PARTICLES << endl;
src/initialize.cpp:    if(params->mpi.MPI_DOMAIN_NUMBER == 0)
src/initialize.cpp:    IONS->mn.zeros(IONS->NSP);
src/initialize.cpp:    IONS->EX_p.zeros(IONS->NSP);
src/initialize.cpp:    IONS->BX_p.zeros(IONS->NSP);
src/initialize.cpp:    IONS->dBX_p.zeros(IONS->NSP);
src/initialize.cpp:    IONS->ddBX_p.zeros(IONS->NSP);
src/initialize.cpp:    IONS->wxc.zeros(IONS->NSP);
src/initialize.cpp:    IONS->wxl.zeros(IONS->NSP);
src/initialize.cpp:    IONS->wxr.zeros(IONS->NSP);
src/initialize.cpp:    IONS->wxc_.zeros(IONS->NSP);
src/initialize.cpp:    IONS->wxl_.zeros(IONS->NSP);
src/initialize.cpp:    IONS->wxr_.zeros(IONS->NSP);
src/initialize.cpp:    // Initialize particle-defined quantities:
src/initialize.cpp:    IONS->n_p.zeros(IONS->NSP);
src/initialize.cpp:    IONS->nv_p.zeros(IONS->NSP);
src/initialize.cpp:    IONS->Tpar_p.zeros(IONS->NSP);
src/initialize.cpp:    IONS->Tper_p.zeros(IONS->NSP);
src/initialize.cpp:    IONS->f1.zeros(IONS->NSP);
src/initialize.cpp:    IONS->f2.zeros(IONS->NSP);
src/initialize.cpp:    IONS->f3.zeros(IONS->NSP);
src/initialize.cpp:    IONS->dE1.zeros(IONS->NSP);
src/initialize.cpp:    IONS->dE2.zeros(IONS->NSP);
src/initialize.cpp:    IONS->dE3.zeros(IONS->NSP);
src/initialize.cpp:    IONS->a_p.ones(IONS->NSP);
src/initialize.cpp:    // Initialize mesh-defined quantities:
src/initialize.cpp:    IONS->n_m.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->n_m_.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->n_m__.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->n_m___.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->nv_m.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->nv_m_.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->nv_m__.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->P11_m.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->P22_m.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->Tpar_m.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.cpp:    IONS->Tper_m.zeros(params->mesh.NX_IN_SIM + 2);
src/initialize.h:// User-defined headers:
src/particleBC.cpp:    MPI_Allreduce(v, &recvbuf, 1, MPI_DOUBLE, MPI_SUM, params->mpi.COMM);
src/particleBC.cpp:    if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/particleBC.cpp:        int numIonSpecies = IONS->size();
src/particleBC.cpp:            int NSP = IONS->at(aa).NSP;
src/particleBC.cpp:            double Ma = IONS->at(aa).M;
src/particleBC.cpp:                if (IONS->at(aa).X_p(ii) <= 0)
src/particleBC.cpp:                    IONS->at(aa).f1(ii) = 1;
src/particleBC.cpp:                    double KE = 0.5*Ma*dot(IONS->at(aa).V_p.row(ii), IONS->at(aa).V_p.row(ii));
src/particleBC.cpp:                    IONS->at(aa).dE1(ii) = KE;
src/particleBC.cpp:                    IONS->at(aa).X_p(ii) = IONS->at(aa).X_p(ii) + params->mesh.LX;
src/particleBC.cpp:                if (IONS->at(aa).X_p(ii) >= params->mesh.LX)
src/particleBC.cpp:                    IONS->at(aa).f2(ii) = 1;
src/particleBC.cpp:                    double KE = 0.5*Ma*dot(IONS->at(aa).V_p.row(ii), IONS->at(aa).V_p.row(ii));
src/particleBC.cpp:                    IONS->at(aa).dE2(ii) = KE;
src/particleBC.cpp:                    IONS->at(aa).X_p(ii) = IONS->at(aa).X_p(ii) - params->mesh.LX;
src/particleBC.cpp:    int NSP(IONS->.NSP);
src/particleBC.cpp:    double DT = params->DT*CS->time;
src/particleBC.cpp:    for(int ss=0;ss<IONS->size();ss++)
src/particleBC.cpp:        if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/particleBC.cpp:            double alpha = IONS->at(ss).NCP;
src/particleBC.cpp:            double G = IONS->at(ss).p_BC.G;
src/particleBC.cpp:            int NSP(IONS->at(ss).NSP);
src/particleBC.cpp:                    S1_private += IONS->at(ss).f1(ii);
src/particleBC.cpp:                    S2_private += IONS->at(ss).f2(ii);
src/particleBC.cpp:            IONS->at(ss).p_BC.S1   += S1_global;
src/particleBC.cpp:            IONS->at(ss).p_BC.S2   += S2_global;
src/particleBC.cpp:            IONS->at(ss).p_BC.GSUM += G;
src/particleBC.cpp:            double S_total  = IONS->at(ss).p_BC.S1 + IONS->at(ss).p_BC.S2;
src/particleBC.cpp:                double S_total  = IONS->at(ss).p_BC.S1 + IONS->at(ss).p_BC.S2;
src/particleBC.cpp:                double GSUM  = IONS->at(ss).p_BC.GSUM;
src/particleBC.cpp:                    if (params->mpi.IS_PARTICLES_ROOT)
src/particleBC.cpp:                IONS->at(ss).p_BC.a_new = a_new;
src/particleBC.cpp:                IONS->at(ss).p_BC.S1   = 0;
src/particleBC.cpp:                IONS->at(ss).p_BC.S2   = 0;
src/particleBC.cpp:                IONS->at(ss).p_BC.GSUM = 0;
src/particleBC.cpp:    for(int ss=0;ss<IONS->size();ss++)
src/particleBC.cpp:		if (params->mpi.COMM_COLOR == PARTICLES_MPI_COLOR)
src/particleBC.cpp:            int NSP(IONS->at(ss).NSP);
src/particleBC.cpp:					if ( IONS->at(ss).f1(ii) == 1 || IONS->at(ss).f2(ii) == 1 )
src/particleBC.cpp:                        ec += 0.5*IONS->at(ss).M*dot(IONS->at(ss).V.row(ii), IONS->at(ss).V.row(ii)); // Increase the leaking particles KE
src/particleBC.cpp:						// Re-inject particle:
src/particleBC.cpp:						particleReinjection(ii, params, CS, EB,&IONS->at(ss));
src/particleBC.cpp:						IONS->at(ss).f1(ii) = 0;
src/particleBC.cpp:						IONS->at(ss).f2(ii) = 0;
src/particleBC.cpp:                IONS->at(ss).pCount += pc;
src/particleBC.cpp:                IONS->at(ss).eCount += ec;
src/particleBC.cpp:	if (IONS->p_BC.BC_type == 1 || IONS->p_BC.BC_type == 2)
src/particleBC.cpp:		if (IONS->p_BC.BC_type == 1)
src/particleBC.cpp:			T = IONS->p_BC.T;
src/particleBC.cpp:		if (IONS->p_BC.BC_type == 2)
src/particleBC.cpp:			T = IONS->p_BC.T;
src/particleBC.cpp:			E = IONS->p_BC.E;
src/particleBC.cpp:		double Ma = IONS->M;
src/particleBC.cpp:		double xip = cos(IONS->p_BC.eta);
src/particleBC.cpp:		double Uy = U*sqrt(1 - pow(xip,2));
src/particleBC.cpp:		std::default_random_engine gen(params->mpi.MPI_DOMAIN_NUMBER+1);
src/particleBC.cpp:		double R_1 = sigma_v*sqrt(-2*log(Rm(gen)));
src/particleBC.cpp:		double R_3 = sigma_v*sqrt(-2*log(Rm(gen)));
src/particleBC.cpp:	if (IONS->p_BC.BC_type == 1 || IONS->p_BC.BC_type == 2) // Finite boundary condition
src/particleBC.cpp:		double mean_x = IONS->p_BC.mean_x;
src/particleBC.cpp:		double sigma_x  =  IONS->p_BC.sigma_x;
src/particleBC.cpp:		double new_x = mean_x  + (sigma_x)*sqrt( -2*log(R(0)) )*cos(phi(0));
src/particleBC.cpp:		double dLX = abs(new_x - mean_x);
src/particleBC.cpp:		while(dLX > params->mesh.LX/2)
src/particleBC.cpp:			 new_x = mean_x  + (sigma_x)*sqrt( -2*log(R(0)) )*cos(phi(0));
src/particleBC.cpp:			 dLX  = abs(new_x - mean_x);
src/particleBC.cpp:		IONS->X(ii,0) = new_x;
src/particleBC.cpp:	if (IONS->p_BC.BC_type == 3) // Periodic boundary condition
src/particleBC.cpp:		if (IONS->X(ii,0) > params->mesh.LX)
src/particleBC.cpp:			IONS->X(ii,0) -= params->mesh.LX;
src/particleBC.cpp:		if (IONS->X(ii,0) < 0)
src/particleBC.cpp:			IONS->X(ii,0) += params->mesh.LX;
src/particleBC.cpp:	if (IONS->p_BC.BC_type == 1 || IONS->p_BC.BC_type == 2) // Finite boundary condition
src/particleBC.cpp:		IONS->a(ii) = IONS->p_BC.a_new;
src/particleBC.cpp:    arma::vec x = params->mesh.e_x;
src/particleBC.cpp:    arma::vec y = params->mesh.e_y;
src/particleBC.cpp:    arma::vec z = params->mesh.e_z;
src/particleBC.cpp:    // Field-alinged unit vectors:
src/particleBC.cpp:    b1 = {params->em_IC.BX, params->em_IC.BY, params->em_IC.BZ};
src/particleBC.cpp:    IONS->V(ii,0) = V1(0)*dot(b1,x) + V2(0)*dot(b2,x) + V3(0)*dot(b3,x);
src/particleBC.cpp:    IONS->V(ii,1) = V1(0)*dot(b1,y) + V2(0)*dot(b2,y) + V3(0)*dot(b3,y);
src/particleBC.cpp:    IONS->V(ii,2) = V1(0)*dot(b1,z) + V2(0)*dot(b2,z) + V3(0)*dot(b3,z);
src/particleBC.cpp:    IONS->g(ii) = 1.0/sqrt( 1.0 - dot(IONS->V.row(ii),IONS->V.row(ii))/(F_C*F_C) );
src/particleBC.cpp:    IONS->mu(ii) = 0.5*IONS->g(ii)*IONS->g(ii)*IONS->M*( V2(0)*V2(0) + V3(0)*V3(0) )/params->em_IC.BX;
src/particleBC.cpp:    IONS->Ppar(ii) = IONS->g(ii)*IONS->M*V1(0);
src/particleBC.cpp:    IONS->avg_mu = mean(IONS->mu);
src/main.cpp:// Include user-defined header files:
src/main.cpp:        // - Count how many left the domain
src/main.cpp:        // - Calculate a_new
src/main.cpp:        // Re-inject particles:
src/main.cpp:        // RE-inject particle states based on plasma source type
src/main.cpp:        // - Apply the "a" on the extrapolation but not interpolation.
src/main.cpp:                // Using the Bashford-Adams extrapolation.
src/main.cpp:            double estimatedSimulationTime = ( (double)params.timeIterations*(t2 - t1)/(double)numberOfIterationsForEstimator )/60.0;
src/PIC.h:// User-defined libraries:
src/initDistribution.cpp:    b1 = {params->em_IC.BX, params->em_IC.BY, params->em_IC.BZ};
src/initDistribution.cpp:	IONS->Ppar = zeros(IONS->NSP);
src/initDistribution.cpp:	IONS->g = zeros(IONS->NSP);
src/initDistribution.cpp:	IONS->mu = zeros(IONS->NSP);
src/initDistribution.cpp:	IONS->X.col(0) *= params->mesh.LX;
src/initDistribution.cpp:	IONS->X.col(1) *= params->mesh.LY;
src/initDistribution.cpp:    IONS->X_p = randu<vec>(IONS->NSP)*params->mesh.LX;
src/initDistribution.cpp:	IONS->V_p = zeros(IONS->NSP,2);
src/initDistribution.cpp:    // Maxwellian distribution for the velocity using Box-Muller:
src/initDistribution.cpp:	arma::vec R = randu(IONS->NSP);
src/initDistribution.cpp:	arma::vec phi = 2.0*M_PI*randu<vec>(IONS->NSP);
src/initDistribution.cpp:	arma::vec V2 = IONS->VTper*sqrt( -log(1.0 - R) ) % cos(phi);
src/initDistribution.cpp:	arma::vec V3 = IONS->VTper*sqrt( -log(1.0 - R) ) % sin(phi);
src/initDistribution.cpp:	R = randu<vec>(IONS->NSP);
src/initDistribution.cpp:	phi = 2.0*M_PI*randu<vec>(IONS->NSP);
src/initDistribution.cpp:	arma::vec V1 = IONS->VTpar*sqrt( -log(1.0 - R) ) % sin(phi);
src/initDistribution.cpp:    IONS->V_p.col(0) = V1;
src/initDistribution.cpp:    IONS->V_p.col(1) = V4;
src/initDistribution.cpp:	for(int pp=0;pp<IONS->NSP;pp++)
src/initDistribution.cpp:		IONS->V_p(pp,0) = V1(pp)*dot(b1,x) + V2(pp)*dot(b2,x) + V3(pp)*dot(b3,x);
src/initDistribution.cpp:		IONS->V_p(pp,1) = V1(pp)*dot(b1,y) + V2(pp)*dot(b2,y) + V3(pp)*dot(b3,y);
src/initDistribution.cpp:		IONS->V_p(pp,2) = V1(pp)*dot(b1,z) + V2(pp)*dot(b2,z) + V3(pp)*dot(b3,z);
src/initDistribution.cpp:		//IONS->g(pp) = 1.0/sqrt( 1.0 - dot(IONS->V.row(pp),IONS->V.row(pp))/(F_C*F_C) );
src/initDistribution.cpp:		//IONS->mu(pp) = 0.5*IONS->g(pp)*IONS->g(pp)*IONS->M*( V2(pp)*V2(pp) + V3(pp)*V3(pp) )/params->em_IC.BX;
src/initDistribution.cpp:		//IONS->Ppar(pp) = IONS->g(pp)*IONS->M*V1(pp);
src/initDistribution.cpp:	//IONS->avg_mu = mean(IONS->mu);
src/initDistribution.cpp:    int Tper_NX = IONS->p_IC.Tper_NX;
src/initDistribution.cpp:    int Tpar_NX = IONS->p_IC.Tper_NX;
src/initDistribution.cpp:    int ne_nx   = IONS->p_IC.densityFraction_NX;
src/initDistribution.cpp:    arma::vec S = linspace(0,params->mesh.LX,Tper_NX);
src/initDistribution.cpp:    interp1(S,IONS->p_IC.Tpar_profile,xx,TT3);
src/initDistribution.cpp:    interp1(S,IONS->p_IC.Tper_profile,xx,TT2);
src/initDistribution.cpp:    interp1(S,IONS->p_IC.Tper_profile,xx,TT1);
src/initDistribution.cpp:    double k3=sqrt((IONS->M)/(2.0*M_PI*F_KB*T3));
src/initDistribution.cpp:    double k2=sqrt((IONS->M)/(2.0*M_PI*F_KB*T2));
src/initDistribution.cpp:    double k1=sqrt((IONS->M)/(2.0*M_PI*F_KB*T1));
src/initDistribution.cpp:    double s3=sqrt((IONS->M)/(2.0*F_KB*T3));
src/initDistribution.cpp:    double s2=sqrt((IONS->M)/(2.0*F_KB*T2));
src/initDistribution.cpp:    double s1=sqrt((IONS->M)/(2.0*F_KB*T1));
src/initDistribution.cpp:    double h= (k1*k2*k3)*exp(-sqrt(2)*(((V1*V1)*(s1*s1))+((V2*V2)*(s2*s2))+((V3*V3)*(s3*s3)))); // Pdf for 3-Velocities with temperature profile
src/initDistribution.cpp:    //interp1(S, (params->em_IC.BX/params->em_IC.Bx_profile)%IONS->p_IC.densityFraction_profile,xx,gg); //Ne is multiplied with the compression factor
src/initDistribution.cpp:    interp1(S,IONS->p_IC.densityFraction_profile,xx,gg); //Ne is multiplied with the compression factor
src/initDistribution.cpp:    return(g*h); //target 4-D Pdf
src/initDistribution.cpp:    IONS->X_p = zeros(IONS->NSP);
src/initDistribution.cpp:    IONS->V_p = zeros(IONS->NSP,2);
src/initDistribution.cpp:    // Apply MH algorith for sampling the 4-D target PDF:
src/initDistribution.cpp:    arma::vec X(IONS->NSP,fill::zeros);  // Particles position along x-axis that will be generated using M-H.
src/initDistribution.cpp:    arma::vec V3(IONS->NSP,fill::zeros); //Velocity profile in X
src/initDistribution.cpp:    arma::vec V2(IONS->NSP,fill::zeros); //Velocity profile in Y
src/initDistribution.cpp:    arma::vec V1(IONS->NSP,fill::zeros); //Velocity profile in Z
src/initDistribution.cpp:    std::default_random_engine generator(params->mpi.MPI_DOMAIN_NUMBER+1);
src/initDistribution.cpp:        std::cout << "From Rank: " << params->mpi.MPI_DOMAIN_NUMBER << std::endl;
src/initDistribution.cpp:    X(0)  = 0.5*params->mesh.LX;
src/initDistribution.cpp:    V3(0) = 0.25*IONS->VTpar;
src/initDistribution.cpp:    V2(0) = 0.1*IONS->VTpar;
src/initDistribution.cpp:    V1(0) = 0.5*IONS->VTpar;
src/initDistribution.cpp:    while(iterator < IONS->NSP)
src/initDistribution.cpp:        X_test  = uniform_distribution(generator)*params->mesh.LX;
src/initDistribution.cpp:        V3_test = 10*(IONS->VTper)*((uniform_distribution(generator))-0.5);
src/initDistribution.cpp:        V2_test = 10*(IONS->VTper)*((uniform_distribution(generator))-0.5);
src/initDistribution.cpp:        V1_test = 10*(IONS->VTpar)*((uniform_distribution(generator))-0.5);
src/initDistribution.cpp:        ratio = target(params, IONS, X_test,V3_test, V2_test, V1_test)/target(params, IONS,  X(iterator - 1),V3(iterator - 1),V2(iterator - 1),V1(iterator - 1));
src/initDistribution.cpp:    IONS->V_p.col(0) = V1;
src/initDistribution.cpp:    IONS->V_p.col(1) = V4;
src/initDistribution.cpp:    IONS->X_p = X;
Binary file bin/PICOS++ matches
Makefile:CCXXFLAGS=-std=c++11
Makefile:CCDEFINEFLAGS=-DHDF5_FLOAT	-DHDF5_SINGLE_FILE	-DCHECKS_ON
Makefile:CFLAGS=$(CCXXFLAGS)	-fopenmp	-O3
Makefile:#CCFLAGS=$(CCXXFLAGS)	-g
Makefile:INCLUDE_HDF5=-I$(HDF5_INSTALL)/include
Makefile:INCLUDES=-I$(ARMADILLO_INSTALL)/include	-I$(ARMADILLO_INSTALL)/lib	-I$(ARMADILLO_INSTALL)/lib64
Makefile:EXTLIB=-L$(HDF5_INSTALL)/lib
Makefile:LIB_FLAGS=-L$(ARMADILLO_INSTALL)/lib	-L$(ARMADILLO_INSTALL)/lib64
Makefile:LIB=-lz	-ldl	-lm	-lhdf5_cpp	-larmadillo #-lgfortran
Makefile:OMP_LIB_FLAGS=-lgomp
Makefile:	$(MPICXX)	-c	$(CCFLAGS)	$(CCDEFINEFLAGS)	$<	$(INCLUDES)	$(INCLUDE_HDF5)	$(LIB_FLAGS) -o $@
Makefile:	$(MPICXX)	$(BINARIES)	-o	$@	$(LIB_FLAGS)	$(LIBSHDF)	$(LIB)	$(OMP_LIB_FLAGS)
Makefile:	rm -f $(BIN)/PICOS++	$(OBJ)/*.o	$(SRC)/*~
debug_run_pro.sh:DIMENSIONALITY="1-D"
debug_run_pro.sh:rm -r ${LOC_OUTPUT_FOLDER}"/"${ID}
debug_run_pro.sh:    ddt --connect mpirun --use-hwthread-cpus -np $((NUM_MPI_PROCESSES)) -x LD_LIBRARY_PATH -x OMP_NUM_THREADS=$((NUM_OMP_PER_MPI)) bin/PICOS++ ${DIMENSIONALITY} ${LOC_OUTPUT_FOLDER}
debug_run_pro.sh:    ddt --connect mpirun --use-hwthread-cpus -np $((NUM_MPI_PROCESSES)) -x LD_LIBRARY_PATH -x OMP_NUM_THREADS=$((NUM_OMP_PER_MPI)) bin/PICOS++ ${DIMENSIONALITY} ${LOC_OUTPUT_FOLDER} ${ID}
